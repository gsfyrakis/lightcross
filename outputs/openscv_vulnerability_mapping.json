[
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/smart_billions.sol#L118-L771",
    "contract": "SmartBillions",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/smart_billions.sol#L459-L478",
    "contract": "SmartBillions.commitDividend(address)",
    "vulnerability": "divide-before-multiply",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/smart_billions.sol#L118-L771",
    "contract": "SmartBillions",
    "vulnerability": "erc20-interface",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/smart_billions.sol#L672-L689",
    "contract": "SmartBillions.addHashes(uint256)",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/smart_billions.sol",
    "contract": "SmartBillions",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/lucky_doubler.sol#L11-L191",
    "contract": "LuckyDoubler",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/lucky_doubler.sol#L127-L133",
    "contract": "LuckyDoubler.rand(uint256)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/lucky_doubler.sol#L67-L122",
    "contract": "LuckyDoubler.join()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/lucky_doubler.sol",
    "contract": "LuckyDoubler",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/old_blockhash.sol",
    "contract": "PredictTheBlockHashChallenge",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/old_blockhash.sol",
    "contract": "PredictTheBlockHashChallenge",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/random_number_generator.sol#L14-L25",
    "contract": "RandomNumberGenerator.random(uint256)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/guess_the_random_number.sol#L22-L28",
    "contract": "GuessTheRandomNumberChallenge.guess(uint8)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/guess_the_random_number.sol#L22-L28",
    "contract": "GuessTheRandomNumberChallenge.guess(uint8)",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/guess_the_random_number.sol",
    "contract": "GuessTheRandomNumberChallenge",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/blackjack.sol#L45-L308",
    "contract": "BlackJack",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/blackjack.sol#L15-L22",
    "contract": "Deck.deal(address,uint8)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/blackjack.sol#L273-L278",
    "contract": "BlackJack.getHouseCard(uint8)",
    "vulnerability": "tautology",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/lottery.sol#L11-L68",
    "contract": "Lottery",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/bad_randomness/lottery.sol#L34-L51",
    "contract": "Lottery.makeBet()",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/bad_randomness/lottery.sol",
    "contract": "Lottery",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_bad_randomness.csv",
    "vulnerability_category": "bad_randomness"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_bonus.sol",
    "contract": "Reentrancy_bonus",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_bonus.sol",
    "contract": "Reentrancy_bonus",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol#L56-L81",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol#L37-L50",
    "contract": "ETH_FUND.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "contract": "ETH_FUND",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "contract": "ETH_FUND",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol#L50-L75",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol#L33-L44",
    "contract": "PrivateBank.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol",
    "contract": "PrivateBank",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol#L50-L75",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol#L33-L44",
    "contract": "PrivateBank.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol",
    "contract": "PrivateBank",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/etherstore.sol#L20-L30",
    "contract": "EtherStore.withdrawFunds(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/etherstore.sol",
    "contract": "EtherStore",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/etherstore.sol",
    "contract": "EtherStore",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol#L52-L77",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol#L33-L46",
    "contract": "Private_Bank.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol",
    "contract": "Private_Bank",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_insecure.sol",
    "contract": "Reentrancy_insecure",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_insecure.sol",
    "contract": "Reentrancy_insecure",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_insecure.sol",
    "contract": "Reentrancy_insecure",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol#L74-L98",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol#L48-L61",
    "contract": "ACCURAL_DEPOSIT.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol",
    "contract": "ACCURAL_DEPOSIT",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/etherbank.sol#L18-L23",
    "contract": "EtherBank.withdrawBalance()",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/etherbank.sol",
    "contract": "EtherBank",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/etherbank.sol",
    "contract": "EtherBank",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/etherbank.sol",
    "contract": "EtherBank",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol#L73-L97",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol#L47-L60",
    "contract": "PRIVATE_ETH_CELL.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol",
    "contract": "PRIVATE_ETH_CELL",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/modifier_reentrancy.sol#L15-L17",
    "contract": "ModifierEntrancy.airDrop()",
    "vulnerability": "reentrancy-no-eth",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol#L62-L86",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol#L21-L35",
    "contract": "MY_BANK.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "contract": "MY_BANK",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "contract": "MY_BANK",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol#L73-L97",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol#L47-L60",
    "contract": "BANK_SAFE.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol",
    "contract": "BANK_SAFE",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/reentrance.sol#L21-L29",
    "contract": "Reentrance.withdraw(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrance.sol",
    "contract": "Reentrance",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrance.sol",
    "contract": "Reentrance",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrance.sol",
    "contract": "Reentrance",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L495-L546",
    "contract": "LedgerChannel.consensusCloseChannel(bytes32,uint256,uint256[4],string,string)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L139-L144",
    "contract": "ECTools.toEthereumSignedMessage(string)",
    "vulnerability": "encode-packed-collision",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-133",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "8.3.4 Incorrect Argument Encoding",
        "defect_type": "Algorithm/Method",
        "description": "This defect refers to the misuse of one-way hash functions (i.e., Solidity keccak256) namely in the incorrect encoding of the function arguments, which can result in a higher likelihood of hash collisions for different entries",
        "synonyms": "hash collisions with multiple variable length arguments"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L756-L817",
    "contract": "LedgerChannel.byzantineCloseChannel(bytes32)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L819-L834",
    "contract": "LedgerChannel._isContained(bytes32,bytes,bytes32)",
    "vulnerability": "constant-function-asm",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L819-L834",
    "contract": "LedgerChannel._isContained(bytes32,bytes,bytes32)",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L465-L492",
    "contract": "LedgerChannel.deposit(bytes32,address,uint256,bool)",
    "vulnerability": "reentrancy-no-eth",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol#L380-L418",
    "contract": "LedgerChannel.createChannel(bytes32,address,uint256,address,uint256[2])",
    "vulnerability": "tautology",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/spank_chain_payment.sol",
    "contract": "ECTools",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol#L62-L86",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol#L21-L35",
    "contract": "W_WALLET.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "contract": "W_WALLET",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "contract": "W_WALLET",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L86-L99",
    "contract": "TokenBank.WithdrawToHolder(address,uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L38",
    "contract": "Token.owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L39-L44",
    "contract": "Token.WithdrawToken(address,uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "contract": "TokenBank",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol#L73-L97",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol#L47-L60",
    "contract": "PERSONAL_BANK.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol",
    "contract": "PERSONAL_BANK",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/reentrancy_dao.sol#L13-L22",
    "contract": "ReentrancyDAO.withdrawAll()",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_dao.sol",
    "contract": "ReentrancyDAO",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_dao.sol",
    "contract": "ReentrancyDAO",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_dao.sol",
    "contract": "ReentrancyDAO",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol#L53-L78",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol#L34-L47",
    "contract": "ETH_VAULT.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol",
    "contract": "ETH_VAULT",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/reentrancy_simple.sol#L20-L28",
    "contract": "Reentrance.withdrawBalance()",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_simple.sol",
    "contract": "Reentrance",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_simple.sol",
    "contract": "Reentrance",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_simple.sol",
    "contract": "Reentrance",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol#L64-L89",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol#L47-L58",
    "contract": "PrivateDeposit.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "contract": "PrivateDeposit",
    "vulnerability": "Dependence on tx.origin",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-115",
    "mapped_swc_id": "SWC-115",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "8.1.1 Wrong Caller Identification",
        "defect_type": "Checking",
        "description": "In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",
        "synonyms": "authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "contract": "PrivateDeposit",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol#L81-L105",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol#L55-L69",
    "contract": "MONEY_BOX.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol",
    "contract": "MONEY_BOX",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol#L53-L78",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol#L34-L47",
    "contract": "ETH_VAULT.CashOut(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol",
    "contract": "ETH_VAULT",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol#L62-L86",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol#L21-L35",
    "contract": "WALLET.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "contract": "WALLET",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "contract": "WALLET",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol#L62-L86",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol#L21-L35",
    "contract": "U_BANK.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "contract": "U_BANK",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "contract": "U_BANK",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol#L62-L86",
    "contract": "Log",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol#L21-L35",
    "contract": "X_WALLET.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "contract": "X_WALLET",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "contract": "X_WALLET",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "contract": "Log",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_cross_function.sol",
    "contract": "Reentrancy_cross_function",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_cross_function.sol",
    "contract": "Reentrancy_cross_function",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/reentrancy_cross_function.sol",
    "contract": "Reentrancy_cross_function",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol#L81-L105",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol#L55-L69",
    "contract": "PENNY_BY_PENNY.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol",
    "contract": "PENNY_BY_PENNY",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol#L72-L96",
    "contract": "LogFile",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol#L47-L60",
    "contract": "DEP_BANK.Collect(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol",
    "contract": "LogFile",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol",
    "contract": "DEP_BANK",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/reentrancy/simple_dao.sol#L16-L22",
    "contract": "SimpleDAO.withdraw(uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/simple_dao.sol",
    "contract": "SimpleDAO",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/simple_dao.sol",
    "contract": "SimpleDAO",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/reentrancy/simple_dao.sol",
    "contract": "SimpleDAO",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_reentrancy.csv",
    "vulnerability_category": "reentrancy"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol#L136-L142",
    "contract": "Marriage.sendMessage(string,string,string)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol#L53-L56",
    "contract": "Owned.execute(address,uint256,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol",
    "contract": "Marriage",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol#L15-L23",
    "contract": "FreeEth.GetFreebie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol#L33-L40",
    "contract": "FreeEth.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "contract": "FreeEth",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "contract": "FreeEth",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "contract": "FreeEth",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol#L13-L18",
    "contract": "B.go()",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "contract": "B",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "contract": "B",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "contract": "B",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol#L21-L29",
    "contract": "WhaleGiveaway1.redeem()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol#L39-L46",
    "contract": "WhaleGiveaway1.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol#L11-L19",
    "contract": "airdrop.transfer(address,address,address[],uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "contract": "airdrop",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "contract": "airdrop",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "contract": "airdrop",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol#L14-L20",
    "contract": "RealOldFuckMaker.makeOldFucks(uint32)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol",
    "contract": "RealOldFuckMaker",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol",
    "contract": "RealOldFuckMaker",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L26-L182",
    "contract": "KingOfTheEtherThrone",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L103-L169",
    "contract": "KingOfTheEtherThrone.claimThrone(string)",
    "vulnerability": "divide-before-multiply",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L172-L175",
    "contract": "KingOfTheEtherThrone.sweepCommission(uint256)",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol",
    "contract": "KingOfTheEtherThrone",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol",
    "contract": "KingOfTheEtherThrone",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L39-L132",
    "contract": "TokenSender",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L126-L130",
    "contract": "TokenSender.gas()",
    "vulnerability": "constant-function-asm",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L87-L109",
    "contract": "TokenSender.run()",
    "vulnerability": "reentrancy-no-eth",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L28-L31",
    "contract": "Owned.execute(address,uint256,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol",
    "contract": "TokenSender",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol#L12-L20",
    "contract": "airPort.transfer(address,address,address[],uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "contract": "airPort",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "contract": "airPort",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "contract": "airPort",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol#L62-L95",
    "contract": "WedIndex",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol#L54-L57",
    "contract": "Owned.execute(address,uint256,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol",
    "contract": "WedIndex",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol",
    "contract": "WedIndex",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol#L60-L67",
    "contract": "Delta.withdraw(uint256)",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol",
    "contract": "Delta",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol#L19",
    "contract": "VaultProxy.Owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol#L12-L15",
    "contract": "Proxy.proxy(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L24-L28",
    "contract": "Lotto.withdrawLeftOver()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L12",
    "contract": "Lotto.winner",
    "vulnerability": "uninitialized-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L17-L22",
    "contract": "Lotto.sendToWinner()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/lotto.sol",
    "contract": "Lotto",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol#L20-L28",
    "contract": "WhaleGiveaway2.GetFreebie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol#L38-L45",
    "contract": "WhaleGiveaway2.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol#L11-L19",
    "contract": "demo.transfer(address,address,address[],uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "contract": "demo",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "contract": "demo",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "contract": "demo",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L185-L192",
    "contract": "PoCGame.payout(address)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L141-L169",
    "contract": "PoCGame.play()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L209-L216",
    "contract": "PoCGame.loseWager(uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol#L23-L27",
    "contract": "keepMyEther.withdraw()",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol#L23-L27",
    "contract": "keepMyEther.withdraw()",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "contract": "keepMyEther",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "contract": "keepMyEther",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "contract": "keepMyEther",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "contract": "keepMyEther",
    "vulnerability": "State access after external call",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1254-L1313",
    "contract": "ClockAuctionBase._bid(uint256,uint256)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1689-L1836",
    "contract": "SaleClockAuction",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1091-L1158",
    "contract": "PandaBreeding.giveBirth(uint256,uint256[2],uint256[2])",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2166-L2186",
    "contract": "PandaAuction.bidOnSiringAuction(uint256,uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1958-L1962",
    "contract": "SaleClockAuctionERC20.withdrawERC20Balance(address,address)",
    "vulnerability": "unchecked-transfer",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L747-L764",
    "contract": "PandaOwnership._memcpy(uint256,uint256,uint256)",
    "vulnerability": "constant-function-asm",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1776-L1791",
    "contract": "SaleClockAuction.bid(uint256)",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1000-L1026",
    "contract": "PandaBreeding._breedWith(uint256,uint256,address)",
    "vulnerability": "reentrancy-no-eth",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2460-L2469",
    "contract": "PandaCore.withdrawBalance()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2197-L2200",
    "contract": "PandaAuction.withdrawERC20Balance(address,address)",
    "vulnerability": "unused-return",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol#L11-L19",
    "contract": "EBU.transfer(address,address,address[],uint256[])",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract": "EBU",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract": "EBU",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract": "EBU",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract": "EBU",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract": "EBU",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/unchecked_return_value.sol#L15-L18",
    "contract": "ReturnValue.callnotchecked(address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/unchecked_return_value.sol",
    "contract": "ReturnValue",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol#L11-L25",
    "contract": "Centra4.transfer()",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol",
    "contract": "Centra4",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol",
    "contract": "Centra4",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol#L20-L28",
    "contract": "Honey.GetFreebie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol#L38-L45",
    "contract": "Honey.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "contract": "Honey",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "contract": "Honey",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "contract": "Honey",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L38",
    "contract": "Token.owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L48-L105",
    "contract": "TokenBank",
    "vulnerability": "locked-ether",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-132",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.4 Improper locking during external calls",
        "defect_type": "Timing/Serialization",
        "description": "A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",
        "synonyms": "unexpected ether balance"
      },
      {
        "index": "6.1.3 Improper Locking",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where a contract assumes that all entities participating in a transaction must have the same credit balance before the contract operations can execute. If there are no adequate (e.g., wrong or even missing) locking mechanisms, an attacker can forcefully send credit to the other entity, which would cause the verification of the balance condition to never be met. Thus, the contract may become unusable or show unexpected behavior (or unexpected state changes)",
        "synonyms": "arbitrary sending of ether, balance equality, checking for strict balance equality, incorrectequality, strict check for balance, unexpected ether balance"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L39-L45",
    "contract": "Token.WithdrawToken(address,uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol#L14-L19",
    "contract": "HomeyJar.GetHoneyFromJar()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol#L26-L30",
    "contract": "HomeyJar.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "contract": "HomeyJar",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "contract": "HomeyJar",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "contract": "HomeyJar",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol#L23-L30",
    "contract": "MultiplicatorX3.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "contract": "MultiplicatorX3",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "contract": "MultiplicatorX3",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "contract": "MultiplicatorX3",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "contract": "MultiplicatorX3",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L14-L145",
    "contract": "DrainMe",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L85-L95",
    "contract": "DrainMe.unlockSecret()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L85-L95",
    "contract": "DrainMe.unlockSecret()",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L131-L134",
    "contract": "DrainMe.winPrize()",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol",
    "contract": "DrainMe",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol",
    "contract": "DrainMe",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol#L65-L76",
    "contract": "Splitter.fundPuppets()",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol",
    "contract": "Splitter",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol#L23-L30",
    "contract": "MultiplicatorX4.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "contract": "MultiplicatorX4",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "contract": "MultiplicatorX4",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "contract": "MultiplicatorX4",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "contract": "MultiplicatorX4",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol#L31-L34",
    "contract": "SimpleWallet.sendMoney(address,uint256,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol",
    "contract": "SimpleWallet",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol",
    "contract": "SimpleWallet",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol#L13-L22",
    "contract": "EBU.transfer(address[],uint256[])",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x89c1b3807d4c67df034fffb62f3509561218d30b.sol",
    "contract": "TownCrier",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol#L15-L23",
    "contract": "Freebie.GetFreebie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol#L33-L40",
    "contract": "Freebie.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "contract": "Freebie",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "contract": "Freebie",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "contract": "Freebie",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol#L10-L13",
    "contract": "Caller.callAddress(address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol",
    "contract": "Caller",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol",
    "contract": "Caller",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L38",
    "contract": "Token.owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L48-L105",
    "contract": "TokenBank",
    "vulnerability": "locked-ether",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-132",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.4 Improper locking during external calls",
        "defect_type": "Timing/Serialization",
        "description": "A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",
        "synonyms": "unexpected ether balance"
      },
      {
        "index": "6.1.3 Improper Locking",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where a contract assumes that all entities participating in a transaction must have the same credit balance before the contract operations can execute. If there are no adequate (e.g., wrong or even missing) locking mechanisms, an attacker can forcefully send credit to the other entity, which would cause the verification of the balance condition to never be met. Thus, the contract may become unusable or show unexpected behavior (or unexpected state changes)",
        "synonyms": "arbitrary sending of ether, balance equality, checking for strict balance equality, incorrectequality, strict check for balance, unexpected ether balance"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L39-L45",
    "contract": "Token.WithdrawToken(address,uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L206-L213",
    "contract": "PoCGame.loseWager(uint256)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L138-L166",
    "contract": "PoCGame.play()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L194-L201",
    "contract": "PoCGame.donateToWhale(uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol#L20-L34",
    "contract": "AirDropContract.transfer(address,address[],uint256[])",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "contract": "AirDropContract",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "contract": "AirDropContract",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "contract": "AirDropContract",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L323-L331",
    "contract": "FiftyFlip.sendFunds(address,uint256)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L162-L207",
    "contract": "FiftyFlip.play(uint256)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L128-L159",
    "contract": "FiftyFlip.wager(bool,uint256,uint256,uint8,bytes32,bytes32)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L128-L159",
    "contract": "FiftyFlip.wager(bool,uint256,uint256,uint8,bytes32,bytes32)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol",
    "contract": "FiftyFlip",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol",
    "contract": "FiftyFlip",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L24-L29",
    "contract": "EtherGet.getTokens(uint256,address)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L17-L20",
    "contract": "EtherGet.withdrawTokens(address)",
    "vulnerability": "unchecked-transfer",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L24-L29",
    "contract": "EtherGet.getTokens(uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol",
    "contract": "EtherGet",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol",
    "contract": "EtherGet",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L87-L99",
    "contract": "TokenBank.WithdrawToHolder(address,uint256)",
    "vulnerability": "reentrancy-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L38",
    "contract": "Token.owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L39-L45",
    "contract": "Token.WithdrawToken(address,uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "contract": "TokenBank",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/mishandled.sol#L10-L15",
    "contract": "SendBack.withdrawBalance()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/mishandled.sol",
    "contract": "SendBack",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/mishandled.sol",
    "contract": "SendBack",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol#L20-L28",
    "contract": "WhaleGiveaway1.GetFreebie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol#L38-L45",
    "contract": "WhaleGiveaway1.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "contract": "WhaleGiveaway1",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L431-L434",
    "contract": "daoPOLSKAtokens.FundsTransfer()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L366-L376",
    "contract": "daoPOLSKAtokens.sendTokenAw(address,address,uint256)",
    "vulnerability": "unchecked-transfer",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L366-L376",
    "contract": "daoPOLSKAtokens.sendTokenAw(address,address,uint256)",
    "vulnerability": "reentrancy-no-eth",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L457-L466",
    "contract": "daoPOLSKAtokens.finalize()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol",
    "contract": "daoPOLSKAtokens",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol#L31-L34",
    "contract": "SimpleWallet.sendMoney(address,uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol",
    "contract": "SimpleWallet",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol",
    "contract": "SimpleWallet",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol#L21-L29",
    "contract": "WhaleGiveaway2.redeem()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol#L39-L46",
    "contract": "WhaleGiveaway2.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "contract": "WhaleGiveaway2",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol#L20-L28",
    "contract": "Pie.Get()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol#L38-L45",
    "contract": "Pie.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "contract": "Pie",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "contract": "Pie",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "contract": "Pie",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L38",
    "contract": "Token.owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L48-L105",
    "contract": "TokenBank",
    "vulnerability": "locked-ether",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-132",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.4 Improper locking during external calls",
        "defect_type": "Timing/Serialization",
        "description": "A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",
        "synonyms": "unexpected ether balance"
      },
      {
        "index": "6.1.3 Improper Locking",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where a contract assumes that all entities participating in a transaction must have the same credit balance before the contract operations can execute. If there are no adequate (e.g., wrong or even missing) locking mechanisms, an attacker can forcefully send credit to the other entity, which would cause the verification of the balance condition to never be met. Thus, the contract may become unusable or show unexpected behavior (or unexpected state changes)",
        "synonyms": "arbitrary sending of ether, balance equality, checking for strict balance equality, incorrectequality, strict check for balance, unexpected ether balance"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L39-L45",
    "contract": "Token.WithdrawToken(address,uint256,address)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol#L20-L28",
    "contract": "Pie.GetPie()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol#L38-L45",
    "contract": "Pie.Command(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "contract": "Pie",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "contract": "Pie",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "contract": "Pie",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol#L47-L70",
    "contract": "Lotto.calculateWinner(uint256,uint256)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol#L131-L160",
    "contract": "Lotto.fallback()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol",
    "contract": "Lotto",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol#L9-L17",
    "contract": "demo.transfer(address,address,address[],uint256[])",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "contract": "demo",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "contract": "demo",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "contract": "demo",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "contract": "demo",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol#L19",
    "contract": "VaultProxy.Owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol#L12-L15",
    "contract": "Proxy.proxy(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol#L11-L20",
    "contract": "airDrop.transfer(address,address,address[],uint256,uint256)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "contract": "airDrop",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "contract": "airDrop",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "contract": "airDrop",
    "vulnerability": "Unchecked return value from external call.",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-104",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol#L19",
    "contract": "DepositProxy.Owner",
    "vulnerability": "shadowing-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-119",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.12.1 Use of Same Variable or Function Name In Inherited Contract",
        "defect_type": "Assignment/Initialization",
        "description": "When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",
        "synonyms": "shadow memory, shadowing, shadowing state variables"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol#L12-L15",
    "contract": "Proxy.proxy(address,bytes)",
    "vulnerability": "unchecked-lowlevel",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_unchecked_low_level_calls.csv",
    "vulnerability_category": "unchecked_low_level_calls"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/crypto_roulette.sol#L14-L61",
    "contract": "CryptoRoulette",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/crypto_roulette.sol#L32-L35",
    "contract": "CryptoRoulette.shuffle()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/crypto_roulette.sol#L40",
    "contract": "CryptoRoulette.play(uint256).game",
    "vulnerability": "uninitialized-storage",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/crypto_roulette.sol#L37-L52",
    "contract": "CryptoRoulette.play(uint256)",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/other/crypto_roulette.sol",
    "contract": "CryptoRoulette",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/other/crypto_roulette.sol",
    "contract": "CryptoRoulette",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/other/crypto_roulette.sol",
    "contract": "CryptoRoulette",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/name_registrar.sol#L23",
    "contract": "NameRegistrar.register(bytes32,address).newRecord",
    "vulnerability": "uninitialized-storage",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/open_address_lottery.sol#L67-L70",
    "contract": "OpenAddressLottery.luckyNumberOfAddress(address)",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/open_address_lottery.sol#L91",
    "contract": "OpenAddressLottery.forceReseed().s",
    "vulnerability": "uninitialized-storage",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/other/open_address_lottery.sol#L46-L65",
    "contract": "OpenAddressLottery.participate()",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/other/open_address_lottery.sol",
    "contract": "OpenAddressLottery",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-120",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_other.csv",
    "vulnerability_category": "other"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/short_addresses/short_address_example.sol",
    "contract": "MyToken",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_short_addresses.csv",
    "vulnerability_category": "short_addresses"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/denial_of_service/auction.sol",
    "contract": "DosAuction",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/denial_of_service/send_loop.sol",
    "contract": "Refunder",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/denial_of_service/send_loop.sol",
    "contract": "Refunder",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/denial_of_service/list_dos.sol#L10-L124",
    "contract": "Government",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/denial_of_service/list_dos.sol#L31-L86",
    "contract": "Government.lendGovernmentMoney(address)",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/denial_of_service/list_dos.sol",
    "contract": "Government",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/denial_of_service/dos_address.sol#L9-L36",
    "contract": "DosGas",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_denial_of_service.csv",
    "vulnerability_category": "denial_of_service"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/front_running/odds_and_evens.sol#L34-L46",
    "contract": "OddsAndEvens.andTheWinnerIs()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/front_running/odds_and_evens.sol",
    "contract": "OddsAndEvens",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/front_running/odds_and_evens.sol",
    "contract": "OddsAndEvens",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/front_running/eth_tx_order_dependence_minimal.sol",
    "contract": "EthTxOrderDependenceMinimal",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/front_running/eth_tx_order_dependence_minimal.sol",
    "contract": "EthTxOrderDependenceMinimal",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/front_running/FindThisHash.sol#L14-L19",
    "contract": "FindThisHash.solve(string)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_front_running.csv",
    "vulnerability_category": "front_running"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_04_confused_sign.sol",
    "contract": "Wallet",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_04_confused_sign.sol",
    "contract": "Wallet",
    "vulnerability": "Integer Arithmetic Bugs",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_04_confused_sign.sol",
    "contract": "Wallet",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/mycontract.sol#L18-L22",
    "contract": "MyContract.sendTo(address,uint256)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/mycontract.sol#L18-L22",
    "contract": "MyContract.sendTo(address,uint256)",
    "vulnerability": "tx-origin",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-115",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "8.1.1 Wrong Caller Identification",
        "defect_type": "Checking",
        "description": "In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",
        "synonyms": "authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/mycontract.sol",
    "contract": "MyContract",
    "vulnerability": "Dependence on tx.origin",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-115",
    "mapped_swc_id": "SWC-115",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "8.1.1 Wrong Caller Identification",
        "defect_type": "Checking",
        "description": "In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",
        "synonyms": "authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name1.sol",
    "contract": "Missing",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name1.sol",
    "contract": "Missing",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/phishable.sol#L18-L22",
    "contract": "Phishable.withdrawAll(address)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/phishable.sol#L18-L22",
    "contract": "Phishable.withdrawAll(address)",
    "vulnerability": "tx-origin",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-115",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "8.1.1 Wrong Caller Identification",
        "defect_type": "Checking",
        "description": "In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",
        "synonyms": "authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/phishable.sol",
    "contract": "Phishable",
    "vulnerability": "Dependence on tx.origin",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-115",
    "mapped_swc_id": "SWC-115",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "8.1.1 Wrong Caller Identification",
        "defect_type": "Checking",
        "description": "In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",
        "synonyms": "authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/phishable.sol",
    "contract": "Phishable",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/phishable.sol",
    "contract": "Phishable",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/mapping_write.sol#L11-L30",
    "contract": "Map",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/mapping_write.sol#L12",
    "contract": "Map.owner",
    "vulnerability": "uninitialized-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/mapping_write.sol",
    "contract": "Map",
    "vulnerability": "Write to an arbitrary storage location",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-124",
    "mapped_swc_id": "SWC-124",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.13.2 Write to Arbitrary Storage Location",
        "defect_type": "Checking",
        "description": "In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract",
        "synonyms": "arbitrary write, buffer-overwrite, storage modification, unrestrictedwrite, write to arbitrary storage location"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/mapping_write.sol",
    "contract": "Map",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/mapping_write.sol",
    "contract": "Map",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/FibonacciBalance.sol#L26-L33",
    "contract": "FibonacciBalance.withdraw()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/FibonacciBalance.sol#L36-L39",
    "contract": "FibonacciBalance.fallback()",
    "vulnerability": "controlled-delegatecall",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-112",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.6 Delegatecall to Untrusted Callee",
        "defect_type": "Interface/O-O Messages",
        "description": "Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",
        "synonyms": "code injection, control-flow hijack, cross program invocation, dangerous delegatecall, delegatecall, delegatecall abuse, delegatecall to untrusted callee, tainted delegatecall, unchecked delegatecall function, unrestricteddelegatecall, unsafe delegate call"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/FibonacciBalance.sol#L14",
    "contract": "FibonacciBalance.calculatedFibNumber",
    "vulnerability": "uninitialized-state",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-109",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.2.4 Uninitialized Storage Variables",
        "defect_type": "Assignment/Initialization",
        "description": "In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",
        "synonyms": "uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/FibonacciBalance.sol",
    "contract": "FibonacciBalance",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/FibonacciBalance.sol",
    "contract": "FibonacciBalance",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/proxy.sol#L17-L20",
    "contract": "Proxy.forward(address,bytes)",
    "vulnerability": "controlled-delegatecall",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-112",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.6 Delegatecall to Untrusted Callee",
        "defect_type": "Interface/O-O Messages",
        "description": "Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",
        "synonyms": "code injection, control-flow hijack, cross program invocation, dangerous delegatecall, delegatecall, delegatecall abuse, delegatecall to untrusted callee, tainted delegatecall, unchecked delegatecall function, unrestricteddelegatecall, unsafe delegate call"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/proxy.sol",
    "contract": "Proxy",
    "vulnerability": "Delegatecall to user-supplied address",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-112",
    "mapped_swc_id": "SWC-112",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.6 Delegatecall to Untrusted Callee",
        "defect_type": "Interface/O-O Messages",
        "description": "Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",
        "synonyms": "code injection, control-flow hijack, cross program invocation, dangerous delegatecall, delegatecall, delegatecall abuse, delegatecall to untrusted callee, tainted delegatecall, unchecked delegatecall function, unrestricteddelegatecall, unsafe delegate call"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name2.sol",
    "contract": "Missing",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name2.sol",
    "contract": "Missing",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name3.sol",
    "contract": "Missing",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/incorrect_constructor_name3.sol",
    "contract": "Missing",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/rubixi.sol#L10-L162",
    "contract": "Rubixi",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/rubixi.sol#L99-L105",
    "contract": "Rubixi.collectPercentOfFees(uint256)",
    "vulnerability": "divide-before-multiply",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/rubixi.sol#L99-L105",
    "contract": "Rubixi.collectPercentOfFees(uint256)",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/multiowned_vulnerable.sol",
    "contract": "TestContract",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/multiowned_vulnerable.sol",
    "contract": "TestContract",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_02_refund_nosub.sol",
    "contract": "Wallet",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_02_refund_nosub.sol",
    "contract": "Wallet",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/arbitrary_location_write_simple.sol#L9-L40",
    "contract": "Wallet",
    "vulnerability": "controlled-array-length",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-128",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "2.1.2 Improper Exception Handling in a Loop",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",
        "synonyms": "callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/access_control/arbitrary_location_write_simple.sol#L25-L29",
    "contract": "Wallet.PopBonusCode()",
    "vulnerability": "tautology",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/arbitrary_location_write_simple.sol",
    "contract": "Wallet",
    "vulnerability": "Write to an arbitrary storage location",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-124",
    "mapped_swc_id": "SWC-124",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.13.2 Write to Arbitrary Storage Location",
        "defect_type": "Checking",
        "description": "In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract",
        "synonyms": "arbitrary write, buffer-overwrite, storage modification, unrestrictedwrite, write to arbitrary storage location"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol",
    "contract": "Wallet",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol",
    "contract": "Wallet",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol",
    "contract": "Wallet",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_access_control.csv",
    "vulnerability_category": "access_control"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "TimeLock",
    "vulnerability": "TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "Token",
    "vulnerability": "Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "Parameter",
    "vulnerability": "Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_add.sol",
    "contract": "TimeLock",
    "vulnerability": "TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_add.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_add.sol",
    "contract": "Token",
    "vulnerability": "Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_add.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_add.sol",
    "contract": "Parameter",
    "vulnerability": "Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "TimeLock",
    "vulnerability": "TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "Token",
    "vulnerability": "Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "Parameter",
    "vulnerability": "Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "Version",
    "vulnerability": "Version constraint ^0.4.16 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "Parameter",
    "vulnerability": "Parameter BasicToken.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/BECToken.sol#65) is not in mixedCase",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "BecToken",
    "vulnerability": "BecToken.BecToken() (smartbugs-dataset/arithmetic/BECToken.sol#297-300) uses literals with too many digits:",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "BecToken",
    "vulnerability": "BecToken.decimals (smartbugs-dataset/arithmetic/BECToken.sol#292) should be constant ",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "batchTransfer",
    "vulnerability": "batchTransfer(address[],uint256) should be declared external:",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_minimal.sol",
    "contract": "IntegerOverflowAdd",
    "vulnerability": "==== Integer Arithmetic Bugs ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/insecure_transfer.sol",
    "contract": "IntegerOverflowMappingSym1",
    "vulnerability": "==== Exception State ====",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/insecure_transfer.sol",
    "contract": "IntegerOverflowMappingSym1",
    "vulnerability": "==== Integer Arithmetic Bugs ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/timelock.sol",
    "contract": "TimeLock",
    "vulnerability": "==== Dependence on predictable environment variable ====",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/timelock.sol",
    "contract": "TimeLock",
    "vulnerability": "==== Transaction Order Dependence ====",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_1.sol",
    "contract": "Overflow_Add",
    "vulnerability": "==== Integer Arithmetic Bugs ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_mapping_sym_1.sol",
    "contract": "IntegerOverflowMappingSym1",
    "vulnerability": "==== Integer Arithmetic Bugs ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-101",
    "mapped_swc_id": "SWC-101",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "7.1.1 Integer Underflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow"
      },
      {
        "index": "7.1.2 Integer Overflow",
        "defect_type": "Checking",
        "description": "This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type",
        "synonyms": "arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow"
      },
      {
        "index": "7.2.1 Divide by Zero",
        "defect_type": "Checking",
        "description": "This issue refers to the attempt of a program to divide a value by zero",
        "synonyms": "arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk"
      },
      {
        "index": "7.2.2 Integer Division",
        "defect_type": "Algorithm/Method",
        "description": "At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",
        "synonyms": "integer division, numerical precision error"
      },
      {
        "index": "7.3.1 Truncation Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",
        "synonyms": "integer overflow and underflow, truncation bugs"
      },
      {
        "index": "7.3.2 Signedness Bugs",
        "defect_type": "Assignment/Initialization",
        "description": "The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen)",
        "synonyms": "signedness bugs"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/integer_overflow_mul.sol",
    "contract": "IntegerOverflowMappingSym1",
    "vulnerability": "==== Exception State ====",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/tokensalechallenge.sol",
    "contract": "TokenSaleChallenge",
    "vulnerability": "==== Unprotected Ether Withdrawal ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/arithmetic/BECToken.sol",
    "contract": "TokenSaleChallenge",
    "vulnerability": "==== Unprotected Ether Withdrawal ====",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_arithmetic.csv",
    "vulnerability_category": "arithmetic"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/roulette.sol#L15-L24",
    "contract": "Roulette.fallback()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/roulette.sol#L15-L24",
    "contract": "Roulette.fallback()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/roulette.sol#L15-L24",
    "contract": "Roulette.fallback()",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/roulette.sol",
    "contract": "Roulette",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/roulette.sol",
    "contract": "Roulette",
    "vulnerability": "Unprotected Ether Withdrawal",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-105",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/governmental_survey.sol#L30-L40",
    "contract": "Governmental.resetInvestment()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/governmental_survey.sol#L45-L52",
    "contract": "Attacker.attack(address,uint256)",
    "vulnerability": "tautology",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/governmental_survey.sol#L30-L40",
    "contract": "Governmental.resetInvestment()",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/governmental_survey.sol",
    "contract": "Attacker",
    "vulnerability": "External Call To User-Supplied Address",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-107",
    "mapped_swc_id": "SWC-107",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.1.1 Unsafe Credit Transfer",
        "defect_type": "Algorithm/Method",
        "description": "Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",
        "synonyms": "buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy"
      },
      {
        "index": "1.1.2 Unsafe System State Changes",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",
        "synonyms": "reentrancy, reentrancybenign, reentrancynoeth"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57",
    "contract": "EtherLotto.play()",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57",
    "contract": "EtherLotto.play()",
    "vulnerability": "weak-prng",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-120",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "5.1 Bad Randomness",
        "defect_type": "Algorithm/Method",
        "description": "This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",
        "synonyms": "bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57",
    "contract": "EtherLotto.play()",
    "vulnerability": "incorrect-equality",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-123",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "6.2.2 Extraneous Input Validation",
        "defect_type": "Checking",
        "description": "In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",
        "synonyms": "requirement violation"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol",
    "contract": "EtherLotto",
    "vulnerability": "Exception State",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-110",
    "mapped_swc_id": "SWC-110",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "5.4.2 Wrong Selection of Guard Function",
        "defect_type": "Function/Class/Object",
        "description": "Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",
        "synonyms": "assert violation, assertfail, assertion failure, assertion violation"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol",
    "contract": "EtherLotto",
    "vulnerability": "Dependence on predictable environment variable",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-116",
    "mapped_swc_id": "SWC-116",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.1 Incorrect Use of Event Blockchain variables for Time",
        "defect_type": "Timing/Serialization",
        "description": "Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",
        "synonyms": "block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol",
    "contract": "EtherLotto",
    "vulnerability": "Multiple Calls in a Single Transaction",
    "severity": "Low",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-113",
    "mapped_swc_id": "SWC-113",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "1.3.2 Improper Exception Handling of External Calls",
        "defect_type": "Checking",
        "description": "In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",
        "synonyms": "denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "mythril",
    "file": "smartbugs-dataset/time_manipulation/ether_lotto.sol",
    "contract": "EtherLotto",
    "vulnerability": "Transaction Order Dependence",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC-114",
    "mapped_swc_id": "SWC-114",
    "mapping_method": "SWC-ID",
    "openscv_entries": [
      {
        "index": "6.1.2 Incorrect Function Call Order",
        "defect_type": "Timing/Serialization",
        "description": "This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",
        "synonyms": "concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)"
      },
      {
        "index": "6.1.4 Transfer Pre-Condition Dependent on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",
        "synonyms": "front running, tod, todtransfer, transaction order dependence"
      },
      {
        "index": "6.1.5 Transfer Amount Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred",
        "synonyms": "tod, todamount, transaction order dependence"
      },
      {
        "index": "6.1.6 Transfer Recipient Depending on Transaction Order",
        "defect_type": "Timing/Serialization",
        "description": "In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",
        "synonyms": "direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/lottopollo.sol#L11-L24",
    "contract": "lottopollo.payOut(uint256)",
    "vulnerability": "arbitrary-send-eth",
    "severity": "High",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-105",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "4.2 Unprotected Transfer Value",
        "defect_type": "Checking",
        "description": "The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",
        "synonyms": "arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  },
  {
    "tool": "slither",
    "file": "smartbugs-dataset/time_manipulation/lottopollo.sol#L11-L24",
    "contract": "lottopollo.payOut(uint256)",
    "vulnerability": "unchecked-send",
    "severity": "Medium",
    "original_swc_id": "SWC-ID: https://swcregistry.io/docs/SWC- ",
    "mapped_swc_id": "SWC-104",
    "mapping_method": "Keyword",
    "openscv_entries": [
      {
        "index": "1.3.1 Improper Check of External Call Return Value",
        "defect_type": "Checking",
        "description": "This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",
        "synonyms": "call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn"
      }
    ],
    "has_match": true,
    "source_file": "output_time_manipulation.csv",
    "vulnerability_category": "time_manipulation"
  }
]