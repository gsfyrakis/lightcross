tool,file,contract,vulnerability,severity,original_swc_id,mapped_swc_id,mapping_method,openscv_index,openscv_defect_type,openscv_description,source_file,vulnerability_category
slither,smartbugs-dataset/bad_randomness/smart_billions.sol#L118-L771,SmartBillions,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/smart_billions.sol#L459-L478,SmartBillions.commitDividend(address),divide-before-multiply,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/smart_billions.sol#L118-L771,SmartBillions,erc20-interface,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/smart_billions.sol#L672-L689,SmartBillions.addHashes(uint256),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/smart_billions.sol,SmartBillions,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/lucky_doubler.sol#L11-L191,LuckyDoubler,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/lucky_doubler.sol#L127-L133,LuckyDoubler.rand(uint256),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/lucky_doubler.sol#L67-L122,LuckyDoubler.join(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/lucky_doubler.sol,LuckyDoubler,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/old_blockhash.sol,PredictTheBlockHashChallenge,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/old_blockhash.sol,PredictTheBlockHashChallenge,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/random_number_generator.sol#L14-L25,RandomNumberGenerator.random(uint256),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/guess_the_random_number.sol#L22-L28,GuessTheRandomNumberChallenge.guess(uint8),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/guess_the_random_number.sol#L22-L28,GuessTheRandomNumberChallenge.guess(uint8),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/guess_the_random_number.sol,GuessTheRandomNumberChallenge,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/blackjack.sol#L45-L308,BlackJack,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/blackjack.sol#L15-L22,"Deck.deal(address,uint8)",weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/blackjack.sol#L273-L278,BlackJack.getHouseCard(uint8),tautology,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/lottery.sol#L11-L68,Lottery,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_bad_randomness.csv,bad_randomness
slither,smartbugs-dataset/bad_randomness/lottery.sol#L34-L51,Lottery.makeBet(),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/bad_randomness/lottery.sol,Lottery,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_bad_randomness.csv,bad_randomness
mythril,smartbugs-dataset/reentrancy/reentrancy_bonus.sol,Reentrancy_bonus,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_bonus.sol,Reentrancy_bonus,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol#L56-L81,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol#L37-L50,ETH_FUND.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol,ETH_FUND,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol,ETH_FUND,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol#L50-L75,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol#L33-L44,PrivateBank.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol,PrivateBank,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol#L50-L75,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol#L33-L44,PrivateBank.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol,PrivateBank,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/etherstore.sol#L20-L30,EtherStore.withdrawFunds(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/etherstore.sol,EtherStore,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/etherstore.sol,EtherStore,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol#L52-L77,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol#L33-L46,Private_Bank.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol,Private_Bank,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_insecure.sol,Reentrancy_insecure,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_insecure.sol,Reentrancy_insecure,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_insecure.sol,Reentrancy_insecure,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol#L74-L98,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol#L48-L61,ACCURAL_DEPOSIT.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol,ACCURAL_DEPOSIT,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/etherbank.sol#L18-L23,EtherBank.withdrawBalance(),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/etherbank.sol,EtherBank,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/etherbank.sol,EtherBank,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/etherbank.sol,EtherBank,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol#L73-L97,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol#L47-L60,PRIVATE_ETH_CELL.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol,PRIVATE_ETH_CELL,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/modifier_reentrancy.sol#L15-L17,ModifierEntrancy.airDrop(),reentrancy-no-eth,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol#L62-L86,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol#L21-L35,MY_BANK.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol,MY_BANK,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol,MY_BANK,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol#L73-L97,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol#L47-L60,BANK_SAFE.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol,BANK_SAFE,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/reentrance.sol#L21-L29,Reentrance.withdraw(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrance.sol,Reentrance,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrance.sol,Reentrance,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrance.sol,Reentrance,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L495-L546,"LedgerChannel.consensusCloseChannel(bytes32,uint256,uint256[4],string,string)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L139-L144,ECTools.toEthereumSignedMessage(string),encode-packed-collision,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-133,Keyword,8.3.4 Incorrect Argument Encoding,Algorithm/Method,"This defect refers to the misuse of one-way hash functions (i.e., Solidity keccak256) namely in the incorrect encoding of the function arguments, which can result in a higher likelihood of hash collisions for different entries",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L756-L817,LedgerChannel.byzantineCloseChannel(bytes32),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L819-L834,"LedgerChannel._isContained(bytes32,bytes,bytes32)",constant-function-asm,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L819-L834,"LedgerChannel._isContained(bytes32,bytes,bytes32)",incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L465-L492,"LedgerChannel.deposit(bytes32,address,uint256,bool)",reentrancy-no-eth,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/spank_chain_payment.sol#L380-L418,"LedgerChannel.createChannel(bytes32,address,uint256,address,uint256[2])",tautology,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/spank_chain_payment.sol,ECTools,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol#L62-L86,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol#L21-L35,W_WALLET.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol,W_WALLET,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol,W_WALLET,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L86-L99,"TokenBank.WithdrawToHolder(address,uint256)",reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L38,Token.owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L39-L44,"Token.WithdrawToken(address,uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol,TokenBank,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol#L73-L97,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol#L47-L60,PERSONAL_BANK.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,PERSONAL_BANK,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/reentrancy_dao.sol#L13-L22,ReentrancyDAO.withdrawAll(),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_dao.sol,ReentrancyDAO,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_dao.sol,ReentrancyDAO,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_dao.sol,ReentrancyDAO,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol#L53-L78,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol#L34-L47,ETH_VAULT.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol,ETH_VAULT,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/reentrancy_simple.sol#L20-L28,Reentrance.withdrawBalance(),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_simple.sol,Reentrance,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_simple.sol,Reentrance,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_simple.sol,Reentrance,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol#L64-L89,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol#L47-L58,PrivateDeposit.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol,PrivateDeposit,Dependence on tx.origin,Low,SWC-ID: https://swcregistry.io/docs/SWC-115,SWC-115,SWC-ID,8.1.1 Wrong Caller Identification,Checking,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol,PrivateDeposit,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol#L81-L105,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol#L55-L69,MONEY_BOX.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol#L53-L78,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol#L34-L47,ETH_VAULT.CashOut(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol,ETH_VAULT,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol#L62-L86,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol#L21-L35,WALLET.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol,WALLET,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol,WALLET,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol#L62-L86,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol#L21-L35,U_BANK.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,U_BANK,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,U_BANK,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol#L62-L86,Log,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol#L21-L35,X_WALLET.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol,X_WALLET,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol,X_WALLET,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol,Log,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_cross_function.sol,Reentrancy_cross_function,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_cross_function.sol,Reentrancy_cross_function,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/reentrancy_cross_function.sol,Reentrancy_cross_function,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol#L81-L105,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol#L55-L69,PENNY_BY_PENNY.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol,PENNY_BY_PENNY,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol#L72-L96,LogFile,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol#L47-L60,DEP_BANK.Collect(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol,LogFile,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol,DEP_BANK,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/reentrancy/simple_dao.sol#L16-L22,SimpleDAO.withdraw(uint256),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/simple_dao.sol,SimpleDAO,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/simple_dao.sol,SimpleDAO,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_reentrancy.csv,reentrancy
mythril,smartbugs-dataset/reentrancy/simple_dao.sol,SimpleDAO,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_reentrancy.csv,reentrancy
slither,smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol#L136-L142,"Marriage.sendMessage(string,string,string)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol#L53-L56,"Owned.execute(address,uint256,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol,Marriage,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol#L15-L23,FreeEth.GetFreebie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol#L33-L40,"FreeEth.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol#L13-L18,B.go(),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol,B,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol,B,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol,B,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol#L21-L29,WhaleGiveaway1.redeem(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol#L39-L46,"WhaleGiveaway1.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol#L11-L19,"airdrop.transfer(address,address,address[],uint256)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol,airdrop,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol,airdrop,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol,airdrop,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol#L14-L20,RealOldFuckMaker.makeOldFucks(uint32),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol,RealOldFuckMaker,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol,RealOldFuckMaker,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L26-L182,KingOfTheEtherThrone,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L103-L169,KingOfTheEtherThrone.claimThrone(string),divide-before-multiply,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol#L172-L175,KingOfTheEtherThrone.sweepCommission(uint256),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol,KingOfTheEtherThrone,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol,KingOfTheEtherThrone,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L39-L132,TokenSender,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L126-L130,TokenSender.gas(),constant-function-asm,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L87-L109,TokenSender.run(),reentrancy-no-eth,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol#L28-L31,"Owned.execute(address,uint256,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol,TokenSender,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol#L12-L20,"airPort.transfer(address,address,address[],uint256)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol,airPort,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol,airPort,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol,airPort,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol#L62-L95,WedIndex,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol#L54-L57,"Owned.execute(address,uint256,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol,WedIndex,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol,WedIndex,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol#L60-L67,Delta.withdraw(uint256),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol,Delta,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol#L19,VaultProxy.Owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol#L12-L15,"Proxy.proxy(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L24-L28,Lotto.withdrawLeftOver(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L12,Lotto.winner,uninitialized-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/lotto.sol#L17-L22,Lotto.sendToWinner(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/lotto.sol,Lotto,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol#L20-L28,WhaleGiveaway2.GetFreebie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol#L38-L45,"WhaleGiveaway2.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol,WhaleGiveaway2,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol,WhaleGiveaway2,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol,WhaleGiveaway2,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol#L11-L19,"demo.transfer(address,address,address[],uint256)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol,demo,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol,demo,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol,demo,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L185-L192,PoCGame.payout(address),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L141-L169,PoCGame.play(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol#L209-L216,PoCGame.loseWager(uint256),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol#L23-L27,keepMyEther.withdraw(),reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol#L23-L27,keepMyEther.withdraw(),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol,keepMyEther,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol,keepMyEther,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol,keepMyEther,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol,keepMyEther,State access after external call,Medium,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1254-L1313,"ClockAuctionBase._bid(uint256,uint256)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1689-L1836,SaleClockAuction,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1091-L1158,"PandaBreeding.giveBirth(uint256,uint256[2],uint256[2])",weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2166-L2186,"PandaAuction.bidOnSiringAuction(uint256,uint256)",reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1958-L1962,"SaleClockAuctionERC20.withdrawERC20Balance(address,address)",unchecked-transfer,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L747-L764,"PandaOwnership._memcpy(uint256,uint256,uint256)",constant-function-asm,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1776-L1791,SaleClockAuction.bid(uint256),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L1000-L1026,"PandaBreeding._breedWith(uint256,uint256,address)",reentrancy-no-eth,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2460-L2469,PandaCore.withdrawBalance(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol#L2197-L2200,"PandaAuction.withdrawERC20Balance(address,address)",unused-return,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol#L11-L19,"EBU.transfer(address,address,address[],uint256[])",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol,EBU,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol,EBU,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol,EBU,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol,EBU,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol,EBU,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/unchecked_return_value.sol#L15-L18,ReturnValue.callnotchecked(address),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/unchecked_return_value.sol,ReturnValue,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol#L11-L25,Centra4.transfer(),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol,Centra4,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol,Centra4,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol#L20-L28,Honey.GetFreebie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol#L38-L45,"Honey.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol,Honey,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol,Honey,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol,Honey,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L38,Token.owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L48-L105,TokenBank,locked-ether,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-132,Keyword,1.4 Improper locking during external calls,Timing/Serialization,"A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol#L39-L45,"Token.WithdrawToken(address,uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol#L14-L19,HomeyJar.GetHoneyFromJar(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol#L26-L30,"HomeyJar.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol,HomeyJar,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol,HomeyJar,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol,HomeyJar,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol#L23-L30,"MultiplicatorX3.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L14-L145,DrainMe,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L85-L95,DrainMe.unlockSecret(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L85-L95,DrainMe.unlockSecret(),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol#L131-L134,DrainMe.winPrize(),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol#L65-L76,Splitter.fundPuppets(),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol,Splitter,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol#L23-L30,"MultiplicatorX4.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol,MultiplicatorX4,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol,MultiplicatorX4,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol,MultiplicatorX4,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol,MultiplicatorX4,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol#L31-L34,"SimpleWallet.sendMoney(address,uint256,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol,SimpleWallet,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol,SimpleWallet,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol#L13-L22,"EBU.transfer(address[],uint256[])",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x89c1b3807d4c67df034fffb62f3509561218d30b.sol,TownCrier,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol#L15-L23,Freebie.GetFreebie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol#L33-L40,"Freebie.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol,Freebie,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol,Freebie,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol,Freebie,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol#L10-L13,Caller.callAddress(address),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol,Caller,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol,Caller,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L38,Token.owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L48-L105,TokenBank,locked-ether,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-132,Keyword,1.4 Improper locking during external calls,Timing/Serialization,"A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol#L39-L45,"Token.WithdrawToken(address,uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L206-L213,PoCGame.loseWager(uint256),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L138-L166,PoCGame.play(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol#L194-L201,PoCGame.donateToWhale(uint256),unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol#L20-L34,"AirDropContract.transfer(address,address[],uint256[])",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol,AirDropContract,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol,AirDropContract,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol,AirDropContract,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L323-L331,"FiftyFlip.sendFunds(address,uint256)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L162-L207,FiftyFlip.play(uint256),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L128-L159,"FiftyFlip.wager(bool,uint256,uint256,uint8,bytes32,bytes32)",reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol#L128-L159,"FiftyFlip.wager(bool,uint256,uint256,uint8,bytes32,bytes32)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol,FiftyFlip,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol,FiftyFlip,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L24-L29,"EtherGet.getTokens(uint256,address)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L17-L20,EtherGet.withdrawTokens(address),unchecked-transfer,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol#L24-L29,"EtherGet.getTokens(uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol,EtherGet,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol,EtherGet,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L87-L99,"TokenBank.WithdrawToHolder(address,uint256)",reentrancy-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L38,Token.owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol#L39-L45,"Token.WithdrawToken(address,uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol,TokenBank,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/mishandled.sol#L10-L15,SendBack.withdrawBalance(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/mishandled.sol,SendBack,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/mishandled.sol,SendBack,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol#L20-L28,WhaleGiveaway1.GetFreebie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol#L38-L45,"WhaleGiveaway1.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol,WhaleGiveaway1,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol,WhaleGiveaway1,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol,WhaleGiveaway1,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L431-L434,daoPOLSKAtokens.FundsTransfer(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L366-L376,"daoPOLSKAtokens.sendTokenAw(address,address,uint256)",unchecked-transfer,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L366-L376,"daoPOLSKAtokens.sendTokenAw(address,address,uint256)",reentrancy-no-eth,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-107,Keyword,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol#L457-L466,daoPOLSKAtokens.finalize(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol,daoPOLSKAtokens,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol#L31-L34,"SimpleWallet.sendMoney(address,uint256)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol,SimpleWallet,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol,SimpleWallet,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol#L21-L29,WhaleGiveaway2.redeem(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol#L39-L46,"WhaleGiveaway2.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol,WhaleGiveaway2,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol,WhaleGiveaway2,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol,WhaleGiveaway2,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol#L20-L28,Pie.Get(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol#L38-L45,"Pie.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol,Pie,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol,Pie,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol,Pie,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L38,Token.owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L48-L105,TokenBank,locked-ether,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-132,Keyword,1.4 Improper locking during external calls,Timing/Serialization,"A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol#L39-L45,"Token.WithdrawToken(address,uint256,address)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol#L20-L28,Pie.GetPie(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol#L38-L45,"Pie.Command(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol,Pie,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol,Pie,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol,Pie,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol#L47-L70,"Lotto.calculateWinner(uint256,uint256)",weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol#L131-L160,Lotto.fallback(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/etherpot_lotto.sol,Lotto,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol#L9-L17,"demo.transfer(address,address,address[],uint256[])",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol,demo,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol,demo,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol,demo,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol,demo,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol#L19,VaultProxy.Owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol#L12-L15,"Proxy.proxy(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol#L11-L20,"airDrop.transfer(address,address,address[],uint256,uint256)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol,airDrop,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol,airDrop,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
mythril,smartbugs-dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol,airDrop,Unchecked return value from external call.,Medium,SWC-ID: https://swcregistry.io/docs/SWC-104,SWC-104,SWC-ID,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol#L19,DepositProxy.Owner,shadowing-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-119,Keyword,5.12.1 Use of Same Variable or Function Name In Inherited Contract,Assignment/Initialization,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol#L12-L15,"Proxy.proxy(address,bytes)",unchecked-lowlevel,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_unchecked_low_level_calls.csv,unchecked_low_level_calls
slither,smartbugs-dataset/other/crypto_roulette.sol#L14-L61,CryptoRoulette,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_other.csv,other
slither,smartbugs-dataset/other/crypto_roulette.sol#L32-L35,CryptoRoulette.shuffle(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_other.csv,other
slither,smartbugs-dataset/other/crypto_roulette.sol#L40,CryptoRoulette.play(uint256).game,uninitialized-storage,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_other.csv,other
slither,smartbugs-dataset/other/crypto_roulette.sol#L37-L52,CryptoRoulette.play(uint256),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_other.csv,other
mythril,smartbugs-dataset/other/crypto_roulette.sol,CryptoRoulette,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_other.csv,other
mythril,smartbugs-dataset/other/crypto_roulette.sol,CryptoRoulette,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_other.csv,other
mythril,smartbugs-dataset/other/crypto_roulette.sol,CryptoRoulette,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_other.csv,other
slither,smartbugs-dataset/other/name_registrar.sol#L23,"NameRegistrar.register(bytes32,address).newRecord",uninitialized-storage,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_other.csv,other
slither,smartbugs-dataset/other/open_address_lottery.sol#L67-L70,OpenAddressLottery.luckyNumberOfAddress(address),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_other.csv,other
slither,smartbugs-dataset/other/open_address_lottery.sol#L91,OpenAddressLottery.forceReseed().s,uninitialized-storage,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_other.csv,other
slither,smartbugs-dataset/other/open_address_lottery.sol#L46-L65,OpenAddressLottery.participate(),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_other.csv,other
mythril,smartbugs-dataset/other/open_address_lottery.sol,OpenAddressLottery,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-120,SWC-120,SWC-ID,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_other.csv,other
slither,smartbugs-dataset/short_addresses/short_address_example.sol,MyToken,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_short_addresses.csv,short_addresses
mythril,smartbugs-dataset/denial_of_service/auction.sol,DosAuction,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_denial_of_service.csv,denial_of_service
mythril,smartbugs-dataset/denial_of_service/send_loop.sol,Refunder,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_denial_of_service.csv,denial_of_service
mythril,smartbugs-dataset/denial_of_service/send_loop.sol,Refunder,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_denial_of_service.csv,denial_of_service
slither,smartbugs-dataset/denial_of_service/list_dos.sol#L10-L124,Government,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_denial_of_service.csv,denial_of_service
slither,smartbugs-dataset/denial_of_service/list_dos.sol#L31-L86,Government.lendGovernmentMoney(address),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_denial_of_service.csv,denial_of_service
mythril,smartbugs-dataset/denial_of_service/list_dos.sol,Government,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_denial_of_service.csv,denial_of_service
slither,smartbugs-dataset/denial_of_service/dos_address.sol#L9-L36,DosGas,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_denial_of_service.csv,denial_of_service
slither,smartbugs-dataset/front_running/odds_and_evens.sol#L34-L46,OddsAndEvens.andTheWinnerIs(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_front_running.csv,front_running
mythril,smartbugs-dataset/front_running/odds_and_evens.sol,OddsAndEvens,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_front_running.csv,front_running
mythril,smartbugs-dataset/front_running/odds_and_evens.sol,OddsAndEvens,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_front_running.csv,front_running
mythril,smartbugs-dataset/front_running/eth_tx_order_dependence_minimal.sol,EthTxOrderDependenceMinimal,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_front_running.csv,front_running
mythril,smartbugs-dataset/front_running/eth_tx_order_dependence_minimal.sol,EthTxOrderDependenceMinimal,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_front_running.csv,front_running
slither,smartbugs-dataset/front_running/FindThisHash.sol#L14-L19,FindThisHash.solve(string),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_front_running.csv,front_running
mythril,smartbugs-dataset/access_control/wallet_04_confused_sign.sol,Wallet,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_04_confused_sign.sol,Wallet,Integer Arithmetic Bugs,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_04_confused_sign.sol,Wallet,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/mycontract.sol#L18-L22,"MyContract.sendTo(address,uint256)",arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/mycontract.sol#L18-L22,"MyContract.sendTo(address,uint256)",tx-origin,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-115,Keyword,8.1.1 Wrong Caller Identification,Checking,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/mycontract.sol,MyContract,Dependence on tx.origin,Low,SWC-ID: https://swcregistry.io/docs/SWC-115,SWC-115,SWC-ID,8.1.1 Wrong Caller Identification,Checking,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name1.sol,Missing,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name1.sol,Missing,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/phishable.sol#L18-L22,Phishable.withdrawAll(address),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/phishable.sol#L18-L22,Phishable.withdrawAll(address),tx-origin,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-115,Keyword,8.1.1 Wrong Caller Identification,Checking,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/phishable.sol,Phishable,Dependence on tx.origin,Low,SWC-ID: https://swcregistry.io/docs/SWC-115,SWC-115,SWC-ID,8.1.1 Wrong Caller Identification,Checking,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/phishable.sol,Phishable,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/phishable.sol,Phishable,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/mapping_write.sol#L11-L30,Map,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/mapping_write.sol#L12,Map.owner,uninitialized-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/mapping_write.sol,Map,Write to an arbitrary storage location,High,SWC-ID: https://swcregistry.io/docs/SWC-124,SWC-124,SWC-ID,5.13.2 Write to Arbitrary Storage Location,Checking,"In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/mapping_write.sol,Map,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/mapping_write.sol,Map,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/FibonacciBalance.sol#L26-L33,FibonacciBalance.withdraw(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/FibonacciBalance.sol#L36-L39,FibonacciBalance.fallback(),controlled-delegatecall,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-112,Keyword,1.6 Delegatecall to Untrusted Callee,Interface/O-O Messages,"Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/FibonacciBalance.sol#L14,FibonacciBalance.calculatedFibNumber,uninitialized-state,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-109,Keyword,5.2.4 Uninitialized Storage Variables,Assignment/Initialization,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/FibonacciBalance.sol,FibonacciBalance,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/FibonacciBalance.sol,FibonacciBalance,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/proxy.sol#L17-L20,"Proxy.forward(address,bytes)",controlled-delegatecall,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-112,Keyword,1.6 Delegatecall to Untrusted Callee,Interface/O-O Messages,"Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/proxy.sol,Proxy,Delegatecall to user-supplied address,High,SWC-ID: https://swcregistry.io/docs/SWC-112,SWC-112,SWC-ID,1.6 Delegatecall to Untrusted Callee,Interface/O-O Messages,"Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name2.sol,Missing,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name2.sol,Missing,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name3.sol,Missing,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/incorrect_constructor_name3.sol,Missing,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/rubixi.sol#L10-L162,Rubixi,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/rubixi.sol#L99-L105,Rubixi.collectPercentOfFees(uint256),divide-before-multiply,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/rubixi.sol#L99-L105,Rubixi.collectPercentOfFees(uint256),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/multiowned_vulnerable.sol,TestContract,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/multiowned_vulnerable.sol,TestContract,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_02_refund_nosub.sol,Wallet,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_02_refund_nosub.sol,Wallet,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/arbitrary_location_write_simple.sol#L9-L40,Wallet,controlled-array-length,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-128,Keyword,2.1.2 Improper Exception Handling in a Loop,Algorithm/Method,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",output_access_control.csv,access_control
slither,smartbugs-dataset/access_control/arbitrary_location_write_simple.sol#L25-L29,Wallet.PopBonusCode(),tautology,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/arbitrary_location_write_simple.sol,Wallet,Write to an arbitrary storage location,High,SWC-ID: https://swcregistry.io/docs/SWC-124,SWC-124,SWC-ID,5.13.2 Write to Arbitrary Storage Location,Checking,"In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol,Wallet,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol,Wallet,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_access_control.csv,access_control
mythril,smartbugs-dataset/access_control/wallet_03_wrong_constructor.sol,Wallet,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_access_control.csv,access_control
slither,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,TimeLock,TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,Version,Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,Token,"Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,Version,Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,Parameter,"Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_add.sol,TimeLock,TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_add.sol,Version,Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_add.sol,Token,"Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_add.sol,Version,Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_add.sol,Parameter,"Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_1.sol,TimeLock,TimeLock.withdraw() (smartbugs-dataset/arithmetic/timelock.sol#25-31) uses timestamp for comparisons,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_1.sol,Version,Version constraint ^0.4.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_1.sol,Token,"Token.transfer(address,uint256) (smartbugs-dataset/arithmetic/token.sol#18-25) contains a tautology or contradiction:",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_1.sol,Version,Version constraint ^0.4.18 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/integer_overflow_1.sol,Parameter,"Parameter Token.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/token.sol#18) is not in mixedCase",High,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/BECToken.sol,Version,Version constraint ^0.4.16 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html),High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/BECToken.sol,Parameter,"Parameter BasicToken.transfer(address,uint256)._to (smartbugs-dataset/arithmetic/BECToken.sol#65) is not in mixedCase",High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/BECToken.sol,BecToken,BecToken.BecToken() (smartbugs-dataset/arithmetic/BECToken.sol#297-300) uses literals with too many digits:,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/BECToken.sol,BecToken,BecToken.decimals (smartbugs-dataset/arithmetic/BECToken.sol#292) should be constant ,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/arithmetic/BECToken.sol,batchTransfer,"batchTransfer(address[],uint256) should be declared external:",High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-101,Keyword,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/integer_overflow_minimal.sol,IntegerOverflowAdd,==== Integer Arithmetic Bugs ====,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/insecure_transfer.sol,IntegerOverflowMappingSym1,==== Exception State ====,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/insecure_transfer.sol,IntegerOverflowMappingSym1,==== Integer Arithmetic Bugs ====,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/timelock.sol,TimeLock,==== Dependence on predictable environment variable ====,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/timelock.sol,TimeLock,==== Transaction Order Dependence ====,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/integer_overflow_1.sol,Overflow_Add,==== Integer Arithmetic Bugs ====,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/integer_overflow_mapping_sym_1.sol,IntegerOverflowMappingSym1,==== Integer Arithmetic Bugs ====,High,SWC-ID: https://swcregistry.io/docs/SWC-101,SWC-101,SWC-ID,7.1.1 Integer Underflow,Checking,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/integer_overflow_mul.sol,IntegerOverflowMappingSym1,==== Exception State ====,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/tokensalechallenge.sol,TokenSaleChallenge,==== Unprotected Ether Withdrawal ====,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_arithmetic.csv,arithmetic
mythril,smartbugs-dataset/arithmetic/BECToken.sol,TokenSaleChallenge,==== Unprotected Ether Withdrawal ====,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_arithmetic.csv,arithmetic
slither,smartbugs-dataset/time_manipulation/roulette.sol#L15-L24,Roulette.fallback(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/roulette.sol#L15-L24,Roulette.fallback(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/roulette.sol#L15-L24,Roulette.fallback(),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/roulette.sol,Roulette,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/roulette.sol,Roulette,Unprotected Ether Withdrawal,High,SWC-ID: https://swcregistry.io/docs/SWC-105,SWC-105,SWC-ID,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/governmental_survey.sol#L30-L40,Governmental.resetInvestment(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/governmental_survey.sol#L45-L52,"Attacker.attack(address,uint256)",tautology,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/governmental_survey.sol#L30-L40,Governmental.resetInvestment(),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/governmental_survey.sol,Attacker,External Call To User-Supplied Address,Low,SWC-ID: https://swcregistry.io/docs/SWC-107,SWC-107,SWC-ID,1.1.1 Unsafe Credit Transfer,Algorithm/Method,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57,EtherLotto.play(),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57,EtherLotto.play(),weak-prng,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-120,Keyword,5.1 Bad Randomness,Algorithm/Method,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/ether_lotto.sol#L33-L57,EtherLotto.play(),incorrect-equality,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-123,Keyword,6.2.2 Extraneous Input Validation,Checking,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/ether_lotto.sol,EtherLotto,Exception State,Medium,SWC-ID: https://swcregistry.io/docs/SWC-110,SWC-110,SWC-ID,5.4.2 Wrong Selection of Guard Function,Function/Class/Object,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/ether_lotto.sol,EtherLotto,Dependence on predictable environment variable,Low,SWC-ID: https://swcregistry.io/docs/SWC-116,SWC-116,SWC-ID,6.1.1 Incorrect Use of Event Blockchain variables for Time,Timing/Serialization,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/ether_lotto.sol,EtherLotto,Multiple Calls in a Single Transaction,Low,SWC-ID: https://swcregistry.io/docs/SWC-113,SWC-113,SWC-ID,1.3.2 Improper Exception Handling of External Calls,Checking,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",output_time_manipulation.csv,time_manipulation
mythril,smartbugs-dataset/time_manipulation/ether_lotto.sol,EtherLotto,Transaction Order Dependence,Medium,SWC-ID: https://swcregistry.io/docs/SWC-114,SWC-114,SWC-ID,6.1.2 Incorrect Function Call Order,Timing/Serialization,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/lottopollo.sol#L11-L24,lottopollo.payOut(uint256),arbitrary-send-eth,High,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-105,Keyword,4.2 Unprotected Transfer Value,Checking,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",output_time_manipulation.csv,time_manipulation
slither,smartbugs-dataset/time_manipulation/lottopollo.sol#L11-L24,lottopollo.payOut(uint256),unchecked-send,Medium,SWC-ID: https://swcregistry.io/docs/SWC- ,SWC-104,Keyword,1.3.1 Improper Check of External Call Return Value,Checking,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",output_time_manipulation.csv,time_manipulation
