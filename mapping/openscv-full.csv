Index ,N1,N2,N3,Desc,SWC,DASP,Rameder,CWE,SCD,Synonyms,DefectType,Qualifier
1 Unsafe External Calls,1,0,0,This category represents a set of vulnerabilities in which there is an interaction between at least two contracts,,,,,,,,
1.1 Reentrancy,1,1,0,"The first subcategory is reentrancy, in which two contracts are involved: the vulnerable contract and the malicious contract. Overall, this type of vulnerability occurs when the malicious contract, after initiating a call, is allowed to make new calls to the vulnerable contract before the initial call has been completed. Thus, unexpected state changes may occur, such as depletion of credit. We identified two main types of reentrancy vulnerabilities: one type associated with loss of credit and the other one associated with unexpected state change",,,,,,,,
1.1.1 Unsafe Credit Transfer,1,1,1,"Known due to the DAO attack event, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds",SWC-107,DASP-1,1A,CWE-841,SCD-01,"buggy-locked reentrancy, cross-function re-entrancy, dao, modified reentrancy, re-entrancy, reentrancy, reentrancy vulnerabilities, reentrancy-eth, repetitive call, simple reentrancy",Algorithm/Method,Wrong
1.1.2 Unsafe System State Changes,1,1,2,"This vulnerability is similar in nature to v1.1.1, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues",SWC-107,DASP-1,,CWE-841,SCD-27,"reentrancy, reentrancybenign, reentrancynoeth",Algorithm/Method,Wrong
1.2 Malicious Fallback Function,1,2,0,"Fallback functions are functions that are executed when a program receives a call to a function whose signature does not exist, i.e., either the name does not exist or the parameters do not match the parameters of any of the existing functions. For instance, an attacker could deploy a smart contract with a malicious fallback function, which could be used to drain funds or alter the system's state",-,-,1B,CWE-685,SCD-10,"call to the unknown, unexpected function invocation",Interface/O-O Messages,Wrong
1.3 Improper Check of External Call Result,1,3,0,"This category groups vulnerabilities that verify the execution of external contracts in an improper manner (i.e., verification is wrong or even missing), which affects the subsequent logic of the calling contract. The result of invoking a certain external operation should be verified, first of all, because it may simply fail, but especially because the called operation may be malicious (or may just have been poorly coded, resulting in an unexpected result); thus, the direct use of the result may lead to unexpected behavior",,,,,,,,
1.3.1 Improper Check of External Call Return Value,1,3,1,"This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result)",SWC-104,DASP-4,10A,CWE-252,SCD-11,"call-stack depth attack, calldepth, callstack depth attack, no check after contract invocation, unchecked call return value, unchecked external call, unchecked return values, unusedreturn",Checking,"Missing, Wrong"
1.3.2 Improper Exception Handling of External Calls,1,3,2,"In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability v1.3.1 ). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract)",SWC-113,DASP-5,,CWE-703,SCD-58,"denial of service, dos attack, dos by external contract, dos with failed call, external contract referencing",Checking,"Missing, Wrong"
1.3.3 Improper Check of Low-Level Call Return Value,1,3,3,"Languages like Solidity offer the possibility of using low-level calls that operate over raw addresses. Such calls do not verify that the code exists or the success of the calls. Thus, its use may lead to unexpected behavior. As a result, using such calls can be risky and should be avoided in most cases.",-,-,3A,CWE-372,SCD-37,"checkeffects, inlineassembly, low-level-calls, lowlevelcalls, unchecked call, unchecked low level calls",Interface/O-O Messages,"Missing, Wrong"
1.4 Improper locking during external calls,1,4,0,"A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service",SWC-132,DASP-1,,CWE-667,SCD-15,unexpected ether balance,Timing/Serialization,"Missing, Wrong"
1.5 Interoperability issues with other contracts,1,5,0,"This issue relates to interoperability issues between contracts built in different language versions. Newer contracts may execute or inherit discontinued functionality present in older contracts. For instance, Solidity has introduced the operation code STATICCALL to allow a contract to call another contract (or itself) without modifying the state. Starting from V0.5.0, pure and view functions must now be called using the code STATICCALL instead of the usual CALL code. Consequently, when defining an interface for older contracts, the programmer should only use view instead of constant in the case s/he is absolutely sure that the function will work with STATICCALL",-,-,8F,CWE-843,SCD-36,assemblyusage,Interface/O-O Messages,"Missing, Wrong"
1.6 Delegatecall to Untrusted Callee,1,6,0,"Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., msg.data or sender) of the source contract. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets",SWC-112,DASP-2,1E,CWE-940,SCD-26,"code injection, control-flow hijack, cross program invocation, dangerous delegatecall, delegatecall, delegatecall abuse, delegatecall to untrusted callee, tainted delegatecall, unchecked delegatecall function, unrestricteddelegatecall, unsafe delegate call",Interface/O-O Messages,Extraneous
1.7 Unsafe Non-Blockchain External Call,1,7,0,"Like external command execution, smart contracts also enable access to external files, but it cannot be assured that the nodes will receive identical results.",-,-,,CWE-15,,,,
1.7.1 Unsafe External Web Service Call,1,7,1,"Sometimes, contracts may opt to streamline the development process and reduce effort by reusing external web services through API calls. Nevertheless, this approach can potentially lead to security issues if the returned values vary across different peer nodes. This vulnerability is also known in the literature as Web service",-,-,,CWE-15,,web service,Interface/O-O Messages,Extraneous
1.7.2 Unsafe External Library Call,1,7,2,"Similar to the previously mentioned vulnerability, contracts might incorporate external libraries without a comprehensive understanding of their internal workings. This vulnerability is also known in the literature as External Library Calling",-,-,2E,CWE-829,,external library calling,Interface/O-O Messages,Extraneous
1.7.3 Unsafe External Command Execution,1,7,3,"External command execution is another possibility within smart contracts. Nevertheless, this action cannot guarantee consistent results across all peer nodes.",-,-,,CWE-829,,system command execution,Interface/O-O Messages,Extraneous
1.7.4 Unsafe External File Access,1,7,4,"Like external command execution, smart contracts also enable access to external files, but it cannot be assured that the nodes will receive identical result",-,-,,CWE-829,,external file accessing,Interface/O-O Messages,Extraneous
1.8 Cross Channel Invocation,1,8,0,"Certain blockchain platforms like Hyperledger Fabric permit contracts to call each other. However, when two contracts interact through different channels, inconsistencies can arise in message reception.",-,-,,CWE-435,,cross channel chaincode invocation,Interface/O-O Messages,Wrong
2 Mishandled Events,2,0,0,"This category includes a set of vulnerabilities in which exceptional events are mishandled. In Solidity, there are specific functions that can be used to verify if certain conditions exist and to throw exceptions in the case the conditions are not met, namely require and assert. There are, however, fundamental differences. When the require function returns false, all executed changes are reverted, and all remaining gas fees are refunded. When the assert function returns false, it reverts all changes but consumes all remaining gas. However, such differences have become a frequent source of problems",,,,,,,,
2.1 Improper Exceptional Events Handling,2,1,0,"This first group of vulnerabilities is directly related to exceptional events, which, when mishandled, are many times linked to the loss of atomicity in operations as well as other effects, such as excessive gas consumption or unauthorized access",,,,,,,,
2.1.1 Improper Use of Exception Handling Functions,2,1,1,"Diverse runtime errors (e.g., out-of-gas error, data type overflow error, division by zero error, array-out-of-index error, etc.) may happen after a compiled smart contract is deployed. However, Solidity has many functions for error handling (e.g., throw, assert, require, revert), but their correct use relies on the experience and expertise of the developer. This defect occurs when the developer misuses the handling exception functions, which can lead the program to unexpected behavior",-,-,3B,CWE-248,SCD-14,"exception disorder, exception state, mishandled exception, mishandled exceptions, unexpected revert, unhandled errors, unhandled exception, unhandledexception",Checking,"Missing, Wrong"
2.1.2 Improper Exception Handling in a Loop,2,1,2,"This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish",SWC-128,DASP-1,5B,CWE-400,SCD-35,"callinloop, costly loop, costly-operations-loop, dos with block gas limit, expensive operations in a loop, fusible loops, gas limit dos on a contract via unbounded operations, repeated computation in a loop, revert dos, unboundedmassoperation, unilateral comparison in a loop",Algorithm/Method,Wrong
2.1.3 Incorrect Revert Implementation in a Loop,2,1,3,"In the case of this vulnerability, the developer incorrectly specifies how the revert operation should be handled (in the context of a loop or a transaction composed of multiple operations), which ends up in a partial revert of the whole set of operations that should be reverted",SWC-126,-,4E,CWE-400,SCD-51,"insufficient gas griefing, nonisolated calls (wallet griefing), push dos",Algorithm/Method,"Missing, Wrong"
2.2 Improper Token Exception Handling,2,2,0,"The ERC-20 standard provides functionalities to exchange tokens. Besides describing the functionalities, the standard specifies good practices for developers to implement its features. Regarding the transfer function, exceptional events can become problematic if they are not handled properly",,,,,,,,
2.2.1 Missing Thrown Exception,2,2,1,"Regarding the transfer function (i.e., functionality to transfer tokens from one account to another), the ERC-20 standard recommends to the developer throw an exception when a condition of the caller's account balance does not have enough tokens to spend. This allows the caller to understand the reason for which the transfer is not completed and take appropriate action",-,-,,CWE-474,SCD-67,"erc-20 transfer, missing the transfer event, non-standard implementation of tokens",Interface/O-O Messages,Missing
2.2.2 Extraneous Exception Handling,2,2,2,"This type of defect refers to the implementation of extra actions compared to what is recommended in a certain specification. The specification does not recommend actions like the use of guard functions (e.g., require or assert) in addition to throwing an exception in the case when there is no balance in the caller. The extra actions might be arbitrary and incompatible with the purpose of a transfer functionality (e.g., returning true or false to report the success of the execution)",-,-,9D,CWE-474,,"flawed back-end verification of cexes, infinite loop, token api violation",Interface/O-O Messages,Extraneous
3 Gas Depletion,3,0,0,"This category groups defects that, in different ways, lead to gas depletion of the account used for the smart contract execution",,,,,,,,
3.1 Improper Gas Requirements Checking,3,1,0,"This defect represents missing or wrong checking of the prerequisites (i.e., in terms of gas) for executing a certain operation, causing unnecessary processing and use of memory resources. For cost management reasons, languages offer programmers several ways to deal with the cost of the executing a certain operation in a contract. For instance, for transferring credits, Solidity provides the functions transfer() and send(), which have a limit of 2300 gas units for each execution. An alternative is to build a custom transfer function, where the gas limit is defined by a variable (e.g., address.call.value(ethAmount).gas(gasAmount)()). Despite having several ways of managing the program costs, it is challenging for programmers to predict which part of the code may fail. If an out-of-gas exception is triggered, the result may be unexpected behavior",SWC-126,DASP-7,5E,CWE-691,SCD-45,"extra gas consumption, gas consumption, gas dos, gasless send, gassless send, insufficient gas griefing, opaque predicate, out of gas",Checking,"Missing, Wrong"
3.2 Call with hardcoded gas amount,3,2,0,"This defect refers to the impossibility of adjusting the amount of gas used by a certain program after being deployed. This issue is related to the observation that certain transfer credit in real contracts was being deployed using a fixed amount of gas (i.e., 2300 gas). If the gas cost of EVM instructions changes during, for instance, a hard fork, previously deployed smart contracts will easily break",SWC-134,-,,CWE-655,SCD-76,message call with hardcoded gas amount,Assignment/Initialization,Wrong
4 Erroneous Credit Transfer,4,0,0,This category groups defects which are generally related to improper credit transfer operations.,,,,,,,,
4.1 Improper Check on Transfer Credit,4,1,0,"This defect refers to the absence of verification after a transfer event, which can lead to an erroneous vision of the correct balance of the account. Indeed, the balance of the account may not reflect the currency transferred in an exact manner, leading to potential errors and opening the door to security issue",-,-,,CWE-391,SCD-2,"forged transfer notification, including fake eos transfer, unchecked send",Checking,"Missing, Wrong"
4.2 Unprotected Transfer Value,4,2,0,"The transfer function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute address.balance is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high",SWC-105,DASP-2,6D,CWE-400,SCD-54,"arbitrarily transfer, eth transfer inside the loop, ether leak, manipulated balance, multiple send, transfer forwards all gas, unchecked transfer value, unprotected ether withdrawal, unrestrictedetherflow",Checking,"Missing, Wrong"
4.3 Wrong use of Transfer Credit Function,4,3,0,"Depending on the programming language, there are different ways to carry out credit transfer operations. In Solidity, transfer and send will both allow executing a credit transfer. However, in the case of a problem, transfer will abort the process with an exception, whereas send function will return false, and transaction execution is continued. An attacker may manipulate the send function and be able to continue executing a credit transfer operation without proper authorization.",-,-,,CWE-840,SCD-3,"failed send, send instead of transfer",Function/Class/Object,Wrong
4.4 Missing Token Issuer Verification,4,4,0,"This vulnerability is related to EOSIO blockchain, in which the transfer function allows attackers to win the cryptocurrency without paying a ticket fee.",-,-,6B,CWE-304,,fake eos,Interface/O-O Messages,Missing
4.5 Missing Token Verification of Exchange,4,5,0,"This vulnerability arises when an attacker can perform a fake deposit due to inadequate verification in the exchange implementation, specifically when unsafe usage of transfer or transferFrom functions is present. A potential solution for this issue involves adopting the safeTransferFrom function, which incorporates security checks before invoking the transferFrom, thereby mitigating the risk",-,-,6B,CWE-306,,flawed token verification of dexes,Interface/O-O Messages,Missing
4.6 Fake Notification,4,6,0,"This vulnerability is related to the EOSIO blockchain, specifically in EOS notifications. The problem occurs when the attackers forward the notification from eosio.token to the victim and forge an EOS notification",,-,,CWE-223,,fake notification,Interface/O-O Messages,Extraneous
5 Bad Programming Practices and Language Weaknesses,5,0,0,"This category represents issues that are mostly related to bad programming practices (i.e., error-prone or insecure coding practices) and language weaknesses, which are mostly related to insufficient protection mechanisms offered by the language, allowing the developers to make mistakes that could be avoided, e.g., by language constructs",,,,,,,,
5.1 Bad Randomness,5,1,0,"This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like block.timestamp, blockhash, block.difficulty, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining",SWC-120,DASP-6,2C,CWE-330,SCD-12,"bad randomness, bump seeds, generating randomness, predicable variable dependency, random number generation, use predictable variable, weak sources of randomness from chain attributes",Algorithm/Method,Wrong
5.2 Improper Declaration or Initialization,5,2,0,"The smart contract has resources that are either not initialized or are initialized in an incorrect manner, leading to unexpected behavior",,,,,,,,
5.2.1 Missing Constructor,5,2,1,"A smart contract constructor is a function that is executed exactly once during the lifetime of a contract. It executes at deployment time and initializes state variables, performs a few necessary tasks that the specific contract requires, and sets the contract owner. If there is no constructor, the developer will have to implement such tasks manually, which is prone to security issues (e.g., variables may be set with incorrect values or forgotten, which may result in security problems)",SWC-118,-,,CWE-477,SCD-17,incorrect constructor name,Assignment/Initialization,Missing
5.2.2 Wrong Constructor Name,5,2,2,"Contract published without a constructor because the programmer created a function, imagining that it would behave like a constructor. Usually, the construction function has sensitive code (e.g.,assignment of the owner of the contract), and by declaring a wrong function name, any user can call the function, thus, causing serious security risk",SWC-118,-,10C,CWE-665,SCD-77,"erroneous constructor name, incorrect constructor name, violated access control checks (vacc)",Assignment/Initialization,Wrong
5.2.3 Missing variable initialization,5,2,3,"This defect refers to the lack of initialization of variables that are used throughout the contract. Obviously, the effects can largely vary, depending on the variable itself and on the context in which is being used",-,-,,CWE-908,SCD-25,"golang grammar error, uninitialized variables, uninitialized-local, uninitializedstatevariable",Assignment/Initialization,Missing
5.2.4 Uninitialized Storage Variables,5,2,4,"In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided",SWC-109,-,10B ,CWE-453,SCD-19,"uninitialized storage pointer, uninitialized storage pointers, uninitializedstorage, unitialized storage",Assignment/Initialization,Missing
5.2.5 Extraneous Field Declaration,5,2,5,"This vulnerability occurs when the programmer leaves field declarations in the contract structure, thereby enabling direct access to these fields (i.e., as they are defined in the structure). Given the possibility of the node environment falling out of sync, the contract's field values may diverge and become inconsistent among peer node",-,-,,CWE-665,,field declarations,Assignment/Initialization,Extraneous
5.2.6 Hardcoded Address,5,2,6,This vulnerability occurs when the programmer writes the code with a static address that should be an input variable.,-,-,,CWE-1052,,hardcoded address,Assignment/Initialization,Wrong
5.3 Isolation Phenomena,5,3,0,"This category gathers vulnerabilities that occur due to blockchain synchronization systems (i.e., enforced by consensus mechanisms), which can lead a program to produce different results at different times for the same query",,,,,,,,
5.3.1 Phantom Reads,5,3,1,"The Hyperledger Fabric provides mechanisms for reading the ledger (i.e., getPrivateDataQueryResult), similar to querying conventional databases, but with the difference that the programmer cannot decide about the isolation level of the ledger. Thus, a contract can read out-of-sync node information from the ledger (i.e., during the validation phase) computing and/or processing based on outdated information.",-,-,,CWE-1100,,range query risks,Algorithm/Method,Wrong
5.3.2 Dirty Reads,5,3,2,"In the context of HF, a query may return a key value before its update within the same transaction. As a consequence, this behavior can lead to unexpected results, as the returned value might not reflect the most recent update",-,-,,CWE-1100,,read-write conflict,Algorithm/Method,Wrong
5.4 Error in Function Call,5,4,0,"In a blockchain context, each function in a smart contract is identified by its name, input parameters, and output parameters. Thus, these items compose the function signature, which is used by the contracts to verify that the right function is being called. This category groups defects in which a developer uses a function in the wrong manner: either a wrong signature is used, wrong arguments are used, or a wrong function is called",,,,,,,,
5.4.1 Wrong Function Call,5,4,1,"The issue occurs when a contract executes a certain function at a wrong address, i.e., at the address used by another function, which, however, has the same signature as the intended function",-,-,,CWE-328,SCD-47,type casts,Interface/O-O Messages,Wrong
5.4.2 Wrong Selection of Guard Function,5,4,2,"Assert is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed. Thus, this defect refers to the cases in which the assert function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with require, the impact of this defect can be serious",SWC-110,-,3D,CWE-670,SCD-68,"assert violation, assertfail, assertion failure, assertion violation",Function/Class/Object,Wrong
5.4.3 Function Call with Wrong Arguments,5,4,3,"This defect refers to the presence of certain control characters within the arguments of a function call, namely the right-to-left override control character, which can cause the function to execute with arguments in reverse order. This is a known issue also in other computing areas",SWC-130,-,,CWE-116,SCD-23,"right-to-left-override control character (u+202e), righttoleftoverride, rtlo",Algorithm/Method,Wrong
5.5 Wrong class inheritance order,5,5,0,"Contracts may have inheritance relationships with other contracts. In the case of solidity, the code of the inherited contract is always executed first, e.g., so that state variables are initialized properly. Solidity uses an algorithm named C3 linearization to determine the order in which the contracts are to be executed. Developers specify the inheritance relationships in a inherit statement and may believe that the order in which the inherited contracts are specified in that statement reflects the order in which the linearization algorithm should work. This opens space for security issues due to the wrong order of the contract in the inherit statement",SWC-125,-,8G ,CWE-696,SCD-13,incorrect inheritance order,Relationship,Wrong
5.6 Improper Type Usage,5,6,0,This category groups vulnerabilities in which there is some misuse of types of data structures or functions,,,8A ,,,,,
5.6.1 Missing return type on function,5,6,1,"This vulnerability refers to a missing return type in the definition of a smart contract interface. At runtime, if a contract that implements that interface contains two functions with the same name and arguments but have different return types, there is a chance that the wrong function will be called. This may lead to unexpected results once the calling contract receives the wrong data type",-,-,,CWE-694,SCD-28,"erc 20 standard violation, erc20interface, missing return statement",Interface/O-O Messages,Missing
5.6.2 Function return type mismatch,5,6,2,"In this case, the developer implemented a function (starting from an interface), but it selected the wrong data type for the value to be returned (i.e., it differs from what is specified in the interface)",SWC-127,-,,CWE-694,SCD-29,"arbitrary jump with function type variable, erc721interface",Interface/O-O Messages,Wrong
5.6.3 Parameter type mismatch,5,6,3,"This issue refers to a divergence regarding the types of arguments used in a function that implements an interface. In this situation, even if the call is done with the right function name and arguments, the EVM considers it to be a non-existent function error",-,-,,CWE-704,SCD-46,erc20indexed,Interface/O-O Messages,Wrong
5.6.4 Missing type in variable declaration,5,6,4,"In Solidity, whenever a variable is declared without an associated type, the compiler infers the data type based on the assigned value. This additional computation may lead to higher costs (i.e., in gas) and memory usage and especially allows for overflow or underflow problems to occur. For instance, the compiler may infer that a signed integer is the right datatype for a certain variable, where an unsigned integer should be used",-,-,,CWE-695,SCD-59,unsafe type inference,Assignment/Initialization,Missing
5.6.5 Wrong Type in Variable Declaration,5,6,5,"This issue refers to a wrong selection of datatypes that leads to the allocation of more memory than what would be necessary for the intended function, leading to an increase in gas consumption. As an example, in Solidity, the byte[] type reserves 31 bytes of space for each element, whereas the bytes requires a single byte per element, thus being more space efficient",-,-,5C,CWE-789,SCD-60,"byte array, global variable, type conversion errors, unsafe array's length manipulation",Assignment/Initialization,Wrong
5.6.6 Wrong Type of Function,5,6,6,"In Solidity, it is possible to specify a type for each function. Functions of type view can read data from state variables but cannot modify them, and no gas costs are involved, whereas functions of type pure neither can read nor modify state variables and similarly to view functions, no gas costs are associated with this type of function. This vulnerability occurs when a developer uses the wrong type for a function. For instance, there is an issue reported in Ethereum's GitHub (Ethereum's Github, 2022) in which a state variable conversion operation (from storage to memory) inside a pure function results in a problem (i.e., to avoid this problem, the function type should be view)",-,-,,CWE-668,SCD-69,unsafe type inference,Interface/O-O Messages,Wrong
5.6.7 Non-Identifiable Order in Map Structure Iteration,5,6,7,"In the Golang language, key-value pairs are not guaranteed to be unique when iterating through a Map structure. This potential lack of uniqueness can cause security issues, particularly if these uncertain values are present in operations that involve modifying the ledger. Such situations may lead to an inconsistent ledger state, which could compromise the ledger's integrity and reliability",-,-,,CWE-462,,map structure iteration,Assignment/Initialization,Missing
5.7 Useless Code,5,7,0,"This category groups a set of vulnerabilities in which the program contains a unit of code that, in practice, has no effect",,,,,,,,
5.7.1 Unreachable Payable Function,5,7,1,"This defect refers to the case of contracts that allow the use of functions that accept credit but do not have any functionality for transacting it. They are insecure, as there is no way to recover the credit once it has been sent to the contract",-,-,4B,CWE-561,SCD-31,"be no black hole, disable transferring, freezing ether, frozen ether, is_greedy, leaking ether, leaking ether to arbitraty address, locked ether, locked funds, locked money, locked-ether, lockedether, locking ether, the ether lost or transferred",Interface/O-O Messages,Wrong
5.7.2 No effect code execution,5,7,2,"This vulnerability refers to the presence of code that has no practical purpose (i.e., it has no effect on the intended functionality). Within a smart contract, it increases the size of the program's binary code, which results in more gas consumption than would otherwise be necessary",SWC-135,-,8J,CWE-1164,SCD-34,"calltodefaultconstructor, code with no effects, code-no-effects, dead code, useless assignment",Algorithm/Method,Extraneous
5.7.3 Unused variables,5,7,3,"This defect refers to the declaration of variables that are not used in the contract, which results directly in the allocation of unnecessary space in memory. As a consequence, the gas cost of executing the contract increases as well as the attack surface of the contract. Other effects are related to the readability or maintainability of the code.",SWC-131,-,,CWE-563,SCD-40,"presence of unused variables, redundant sstore, unused state variable, unusedstatevariable",Assignment/Initialization,Extraneous
5.7.4 Inefficient Operation Sequence,5,7,4,"Due to bad programming practices or outdated compilers (i.e., Solidity has more than 350 versions, with the first one being 0.1.1 released in 2015), smart contracts may suffer from gas-inefficient operation sequences. Consequently, such contracts could be deployed with non-optimized bytecode,leading to increased resource and gas consumption",-,-,,CWE-1281,,"push1=not, pushx=pop, swap1=dup2=swap1",Process conformance,Wrong
5.8 Version Issues,5,8,0,"This category refers to issues that relate to the versioning of various aspects, including the use of deprecated versions of functions",,,,,,,,
5.8.1 Undetermined Program Version Prevalence,5,8,1,This defect refers to the case where the developer allows a certain contract to be compiled across multiple versions. This allows the known faults in older versions to be easily activated.,SWC-103,-,9C ,CWE-664,SCD-39,"compiler version not fixed, floating pragma, solcversion",Process conformance,Missing
5.8.2 Outdated Compiler Version,5,8,2,"Contracts that have been developed against an outdated compiler version can bring in several risks, mainly because newer versions may have resolved certain bugs or even introduced security mechanisms to avoid particular issues (e.g., the throw function has been disallowed in Solidity 0.5.0 and superior versions, in favor of assert, require/, and revert).",SWC-102,-,9B,CWE-937,SCD-62,outdated compiler version,Process conformance,Wrong
5.8.3 Use of Deprecated Functions,5,8,3,"Deprecated functions are not recommended due to the fact that they are usually replaced by functions that solve known security issues or even operate in a more efficient manner (i.e., may consume less gas). As an example, sha3 was marked as a deprecated function in Solidity 0.5 and replaced by keccak256, which is more secure and efficient",SWC-111,-,8D ,CWE-477,SCD-70,use of deprecated solidity functions,Function/Class/Object,Wrong
5.9 Inadequate Data Representation,5,9,0,"The numbers to represent the credits (e.g., Ether) can be very large (i.e., literals with many digits are difficult to read and review). Thus it is recommended that the programmer use the native resources of the language to make this representation (e.g., Solidity 10000000000000000000 for 1 ether).",-,-,,CWE-1093,SCD-41,too-many-digits,Assignment/Initialization,Wrong
5.10 Improper Modifier,5,10,0,This group gathers defects that relate to the use of modifiers in functions and variables.,,,,,,,,
5.10.1 Wrong Function Modifier,5,10,1,"This defect refers to the case of functions that are written solely to be used by other contracts (i.e., not within the contract). Such functions should be marked with the external modifier instead of public. The public modifier allows both external and internal calls. Marking a function with external results in gas savings, as every invocation will be using calldata (a special memory region to store arguments, which cannot be later modified by the function) and can avoid unnecessary read and write operations to memory, which occur with internal calls (i.e., that do not use calldata).",SWC-100,-,5D ,CWE-400,SCD-43,"external-function, function default visibility",Algorithm/Method,Wrong
5.10.2 Missing Constant Modifier in Variable Declaration,5,10,2,"Variables that are not modified during the execution flow should be declared as constants to save gas. In the absence of the constant modifier, it is assumed that the variable's value can be changed.",-,-,,CWE-710,SCD-42,constablestates,Assignment/Initialization,Missing
5.10.3 Missing Visibility Modifier in Variable Declaration,5,10,3,"Variables have different visibility states, which determine the context for accessing them. In Solidity, by default, the visibility of state variables and functions is internal, which allows access from functions in the same contract or derived contracts. A developer that is unaware of this may create a contract that allows exposure of sensitive data or allow unexpected behavior.",SWC-108,DASP-2,,CWE-710,SCD-44,"implicit visibility, state variable default visibility, statevariablesdefaultvisibility, visibility level",Assignment/Initialization,Missing
5.11 Redundant Functionality,5,11,0,"Contracts that are written with redundant functionality increase code size and make maintainability difficult. In a simple scenario, a programmer creates a function and later (by bad practices) ends up creating the same functionality again in a new function. He/she identifies a vulnerability in the new function and fixes it, but the old function with the defect is used by the caller.",-,-,,CWE-1041,SCD-61,redundant fallback function,Algorithm/Method,Extraneous
5.12 Shadowing,5,12,0,"This category groups defects in which there are code elements (e.g., a function or a variable) with the same name, which can lead to erroneous and unexpected behavior.",,,,,,,,
5.12.1 Use of Same Variable or Function Name In Inherited Contract,5,12,1,"When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable",SWC-119,-,8H,CWE-1109,SCD-24,"shadow memory, shadowing, shadowing state variables",Assignment/Initialization,Wrong
5.12.2 Variables or Functions Named After Reserved Words,5,12,2,"This bug occurs when creating variables named after keywords of the language itself. For example, in Solidity, creating a variable with the name now conflicts with the function that returns the date and time.",-,-,,CWE-1109,SCD-32,"shadowedbuiltin, shadowing-builtin",Assignment/Initialization,Wrong
5.12.3 Use of the Same Variable or Function Name In a Single Contract,5,12,3,"This vulnerability refers to cases where the same name is used for more than one variable or function inside the contract. This makes the program lose the reference of the variable of the class, assuming the variable of the function as its role",-,-,,CWE-1109,SCD-33,"redefined variable, shadowedlocalvariable",Assignment/Initialization,Wrong
5.13 Bufer-Based Vulnerabilities,5,13,0,"This category refers to overflow vulnerabilities (e.g., stack-based, heap-based) in which it is possible to write more data than what the buffer can hold, thus modifying memory areas outside the expected",,,,,,,,
5.13.1 Stack-based Buffer Overflow,5,13,1,"The EVM keeps an execution stack that manages the execution of contracts. If an attacker is allowed to overflow this stack (e.g., by using specially crafted inputs), it can potentially overwrite control variables (e.g., timestamp or block number) and, for instance, gain unauthorized access to certain resources",-,-,,CWE-121,SCD-49,stack size limit,Checking,"Missing, Wrong"
5.13.2 Write to Arbitrary Storage Location,5,13,2,"In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract",SWC-124,-,8E,CWE-123,SCD-22,"arbitrary write, buffer-overwrite, storage modification, unrestrictedwrite, write to arbitrary storage location",Checking,"Missing, Wrong"
5.13.3 Read from Arbitrary Storage Location,5,13,3,"This vulnerability may cause both underflow and overflow issues. Underflow happens when the program accesses a resource in the buffer area, such as an index, before reaching the intended buffer location. On the other hand, overflow occurs when the program accesses a resource in the buffer area, like an index, beyond the intended buffer location",,,,CWE-127,,"buffer-overflow, buffer-underflow",Checking,"Missing, Wrong"
5.14 Use of Malicious Libraries,5,14,0,This defect refers to the use of third-party libraries containing malicious code.,-,-,2E,CWE-829,SCD-63,"external library calling, malicious libraries",Maintenance of Application Dependencies,"Extraneous, Wrong"
5.15 Typographical Error,5,15,0,"This defect refers to single-digit errors made by programmers while typing source code, e.g., in logic or arithmetic operations. For example, for value assignment, a developer may type by mistake += instead of = or may use ? instead of + or ?? instead of ++",SWC-129,-,8B,CWE-480,SCD-75,typographical error,Algorithm/Method,"Extraneous, Missing, Wrong"
5.16 Wrong Logic,5,16,0,"This vulnerability refers to when the developer makes a systematic logic mistake in the contract, leading repeatable executions to unexpected result",-,-,,CWE-840,,logic loopholes,Algorithm/Method,Wrong
5.17 Wrong moment for token generation,5,17,0,"This vulnerability arises when the token generation process within the contract relies solely on the validity of the receiving address. As a result, malicious programmers can exploit this weakness to generate tokens arbitrarily, gaining the ability to manipulate the token price",-,-,,CWE-179,,generate token after ico,Algorithm/Method,Wrong
6 Incorrect Control Flow,6,0,0,"This category groups a set of vulnerabilities that, if exploited, cause changes in the control flow of the program",,,,,,,,
6.1 Incorrect Sequencing of Behavior,6,1,0,"This category gathers vulnerabilities that end up in a sequence of behaviors that are carried out in the wrong order, leading to unexpected results",,,,,,,,
6.1.1 Incorrect Use of Event Blockchain variables for Time,6,1,1,"Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner",SWC-116,DASP-8,2A ,CWE-829,SCD-7,"block dependency, block information dependency, block no. dependency, block number dependency, block state dependence, block state dependency, block values as a proxy for time, blockinfo dependency, blocktimestamp, event-ordering (eo) bugs, race condition, system timestamp, time dependence, time dependency, time-stamp expansion, timedep, timestamp, timestamp dependence, timestamp dependency, timestamp manipulation",Timing/Serialization,Wrong
6.1.2 Incorrect Function Call Order,6,1,2,"This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order",SWC-114,DASP-7,,CWE-362,SCD-8,"concurrency of program, the transaction ordering, transaction order dependence, transaction order dependency, transaction ordering dependence (tod)",Timing/Serialization,Wrong
6.1.3 Improper Locking,6,1,3,"This issue refers to the case where a contract assumes that all entities participating in a transaction must have the same credit balance before the contract operations can execute. If there are no adequate (e.g., wrong or even missing) locking mechanisms, an attacker can forcefully send credit to the other entity, which would cause the verification of the balance condition to never be met. Thus, the contract may become unusable or show unexpected behavior (or unexpected state changes)",SWC-132,-,1C ,CWE-667,SCD-30,"arbitrary sending of ether, balance equality, checking for strict balance equality, incorrectequality, strict check for balance, unexpected ether balance",Timing/Serialization,"Missing, Wrong"
6.1.4 Transfer Pre-Condition Dependent on Transaction Order,6,1,4,"In the case of this vulnerability, the order in which transactions are executed influence a pre- condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all",SWC-114,DASP-7,2B,CWE-364,-,"front running, tod, todtransfer, transaction order dependence",Timing/Serialization,Wrong
6.1.5 Transfer Amount Depending on Transaction Order,6,1,5,This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred,SWC-114,DASP-7,,CWE-364,SCD-20,"tod, todamount, transaction order dependence",Timing/Serialization,Wrong
6.1.6 Transfer Recipient Depending on Transaction Order,6,1,6,"In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer",SWC-114,DASP-7,,CWE-364,SCD-21,"direct value transfer, tod, todreceiver, transaction order dependence, transaction order dependency, transaction-ordering dependence",Timing/Serialization,Wrong
6.1.7 Exposed state variables,6,1,7,"This vulnerability refers to the case where a developer erroneously exposes a state variable, whose value may then be modified by an attacker so that this modification influences the execution of a certain contract operation. As an example, consider a contract that executes a credit transfer from one user to another and has a require statement for verifying that there is sufficient credit to conclude the operation. If the balance is stored as a public state variable, a malicious use could change its value so that the require is avoided allowing the user to run a transfer that exceeds the amount of credit actually held by the malicious user.",-,-,,CWE-200,SCD-78,"reified object addresses, vulnerable state",Assignment/Initialization,Extraneous
6.1.8 Wrong Transaction Definition,6,1,8,"EOSIO facilitates inter-contract communication through the use of inline actions and defer actions. When a smart contract invokes another contract using inline actions, all these actions are bundled together into a single transaction under the control of the caller. In contrast, defer actions will be executed in a separate transaction and cannot be reverted by the caller. In certain situations, attackers might exploit the ability to rollback inline actions, manipulating the blockchain to deny specific transactions. To mitigate such risks, developers can strategically implement defer actions to create a more secure contract execution flow, protecting against rollback attacks",-,-,,CWE-1251,,rollback,Function/Class/Object,Wrong
6.2 Inadequate Input Validation,6,2,0,"This group refers to defects involving the inadequate validation of functional conditions, which are requirements that a contract must meet so that it can operate correctly. Such conditions may offer protection against certain types of attacks or force certain business rules to be followed.",,,,,,,,
6.2.1 Improper Input Validation,6,2,1,"This type of problem occurs when an attacker calls a certain contract operation using invalid or malicious input data, capable of affecting the functioning of the contract due to the fact that either it does not validate the incoming inputs or validates them in an incorrect manner. For instance, in the context of Solidity, a Short Address Attack occurs when a contract receives less data than it was expecting, which leads the system to fill the missing bytes with zeros. As a consequence, the behavior may become unexpected if the code assumes that the input data will comply with a certain length or format.",-,DASP-9,9A,CWE-20,SCD-66,"avoid non-existing address, has_short_address, invalid input data, shift-parameter-mixup, short address attack, short addresses, shortening of address, unchecked input arguments, unchecked tainted staticcall",Checking,"Missing, Wrong"
6.2.2 Extraneous Input Validation,6,2,2,"In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements.",SWC-123,-,,CWE-573,SCD-74,requirement violation,Checking,Extraneous
7 Arithmetic Issues,7,0,0,This category groups different vulnerabilities that share the outcome of resulting in arithmetic problems,,,,,,,,
7.1 Overflow and Underflow,7,1,0,"This category refers to the use of operations (e.g., addition, subtraction) over values that result in a value that is less than (or greater than) the minimum values (or maximum value) that a variable can hold, which produces a value different from the correct result",,,7A,,,,,
7.1.1 Integer Underflow,7,1,1,This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type,SWC-101,DASP-3,,CWE-191,SCD-4,"arithmetic bugs, flow, has_flows, integer underflow vulnerability, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow/underflow, integer underflow, multi-transaction sequence vulnerabilities, overflow / underflow, overflow and underflow, overflow/underflow, underflow",Checking,"Missing, Wrong"
7.1.2 Integer Overflow,7,1,2,This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type,SWC-101,DASP-3,,CWE-190,SCD-5,"arithmetic bugs, flow, has_flows, integer bug, integer over/underflow, integer overflow, integer overflow and integer underflow, integer overflow and underflow, integer overflow vulnerability, integer overflow/underflow, integer overflows, overflow, overflow / underflow, overflow and underflow, overflow detector, overflow/underflow",Checking,"Missing, Wrong"
7.2 Division Bugs,7,2,0,This category groups issues related to erroneous division operations,,,7C ,,,,,
7.2.1 Divide by Zero,7,2,1,This issue refers to the attempt of a program to divide a value by zero,SWC-101,DASP-3,,CWE-369,SCD-16,"arithmetic bugs, divide by zero, divide-by-zero, division by zero, division-by-zero, zero division risk",Checking,"Missing, Wrong"
7.2.2 Integer Division,7,2,2,"At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation",SWC-101,DASP-3,7B ,CWE-682,SCD-64,"integer division, numerical precision error",Algorithm/Method,Wrong
7.3 Conversion Bugs,7,3,0,This category groups a set of vulnerabilities where there are issues related to the conversion between different datatypes,,,,,,,,
7.3.1 Truncation Bugs,7,3,1,"This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process",SWC-101,DASP-3,,CWE-197,SCD-52,"integer overflow and underflow, truncation bugs",Assignment/Initialization,Wrong
7.3.2 Signedness Bugs,7,3,2,The conversion of a signed integer type to an unsigned type of the same width may change a negative value to a positive one (the opposite may also happen),SWC-101,DASP-3,,CWE-195,SCD-53,signedness bugs,Assignment/Initialization,Wrong
8 Improper Access Control,8,0,0,This category groups a set of vulnerabilities that are strongly related to authentication or access control,,,,,,,,
8.1 Incorrect Authentication or Authorization,8,1,0,"The smart contract fails to properly identify a client or determine its privileges, resulting in wrong access privileges for that particular client",,,,,,,,
8.1.1 Wrong Caller Identification,8,1,1,"In Solidity, tx.origin allows obtaining the address of the account that initiated a transaction and msg.sender allows obtaining the address of the contract that has called the function being executed. The use of the tx.origin for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses tx.origin to check the identity of the caller). Thus, msg.sender will differ from tx.origin. In the case the vulnerable function uses tx.origin for access control, it will allow the user to perform actions it should not be able to.",SWC-115,DASP-2,6A,CWE-1126,SCD-6,"authorization through tx.origin, incorrect check for authorization, missing access control checks (macc), missing authorization verification, the abuse of tx.origin, transaction origin use, transaction state dependence, tx-origin, tx.origin, txorgin, txorigin, use of tx.origin, using tx.origin for authorization",Checking,Wrong
8.1.2 Owner Manipulation,8,1,2,This vulnerability allows an attacker to exploit some function or feature of the smart contract by manipulating the owner control variable. This allows the attacker to perform some kind of restricted operations,-,-,,CWE-732,SCD-55,"freeze account, missing owner check, taint for owner, tainted owner variable, unprotected function, vulnerable access control",Assignment/Initialization,Wrong
8.1.3 Missing verification for program termination,8,1,3,"This issue refers to the lack of a secure verification for terminating a published (deployed) contract, allowing an attacker to terminate it in an unauthorized manner. Selfdestruct is an EVM instruction that is able to nullify the bytecode of a deployed contract. When invoked, it stops the execution of the EVM, deletes the contract's bytecode, and sends the remaining fund to a certain address. Access to this kind of function by non-authorized clients may result in security issues.",SWC-106,-,6C,CWE-1082,SCD-18,"accessible selfdestruct, destroy token, guard suicide, multi-transaction sequence vulnerabilities, self-destruct abusing, selfdestruct, suicidal contract, suicidal contracts, suicide, tainted selfdestruct, unprotected self-destruct, unprotected selfdestruct instruction, unprotected suicide, unrestrictedselfdestruct",Checking,Missing
8.2 Improper Protection of Sensitive Data,8,2,0,This category generally refers to the issues that result in the inability to protect sensitive information from non-authorized clients,,,,,,,,
8.2.1 Exposed private data,8,2,1,"This issue refers to the cases in which contracts store unencrypted sensitive data in public blockchain transactions. Solidity, like other programming languages, support the private keyword that indicates that data is only accessible within the contract itself. However, in blockchain environments, marking a variable with private does not make it fully invisible to the outside world. Miners, which are responsible for validating transactions on the blockchain, can view the code of the contract and the value of its state variables",SWC-136,-,2D,CWE-767,SCD-48,"exposed secret, private modifier, private-not-hidedata, unencrypted private data on-chain",Algorithm/Method,Wrong
8.2.2 Dependency on External State Data,8,2,2,"This vulnerability refers to the use of data that is not under control nor is generated by the contract (i.e., external critical state data). A malicious user may exploit this situation if such data determines the outcome of the execution of the contract",-,-,,CWE-642,SCD-56,unsolvable constraints,Algorithm/Method,"Extraneous, Wrong"
8.3 Cryptography Misuse,8,3,0,This category groups vulnerabilities that generally reflect misuse of cryptography mechanisms,,,,,,,,
8.3.1 Incorrect Verification of Cryptographic Signature,8,3,1,"This issue refers to the wrong verification of the authenticity and integrity of messages with the use of message signatures. As an example, a developer could develop a vulnerable contract that relies on a signature in a signed message hash for representing the earlier verification of previous messages. A client could generate a malicious message with a valid signature and include it in the hash. The contract then would validate the signature and update the hash, indicating that the message was processed",SWC-117,-,6E,CWE-347,SCD-71,"check signature, missing key check, signature malleability, signature-malleability",Interface/O-O Messages,Wrong
8.3.2 Improper Check against Signature Replay Attacks,8,3,2,This defect refers to a situation where a malicious client is able to obtain the message hash of a legitimate transaction and is allowed to use the same signature to impersonate the legitimate client and execute fraudulent transactions,SWC-121,-,2F,CWE-347,SCD-72,missing protection against signature replay attacks,Checking,"Missing, Wrong"
8.3.3 Improper authenticity check,8,3,3,"In this case, a contract may tolerate off-chain signed messages instead of waiting for an on-chain signature. This is usually done with the goal of improving performance but may come at the expense of compromising the authenticity of the message",SWC-122,-,6B,CWE-345,SCD-73,"lack of proper signature verification, missing signer check",Checking,"Missing, Wrong"
8.3.4 Incorrect Argument Encoding,8,3,4,"This defect refers to the misuse of one-way hash functions (i.e., Solidity keccak256) namely in the incorrect encoding of the function arguments, which can result in a higher likelihood of hash collisions for different entries",SWC-133,DASP-2,,CWE-294,SCD-9,hash collisions with multiple variable length arguments,Algorithm/Method,Wrong
