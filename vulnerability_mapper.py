import pandas as pd
import re
import json
import numpy as np
import os
import glob
from typing import Dict, List, Any, Tuple, Optional, Set, Union
import matplotlib.pyplot as plt
from collections import Counter, defaultdict


class OpenScvVulnerabilityMapper:
    """
    Map smart contract vulnerabilities from multiple output CSV files
    to their corresponding classifications in openscv-full.csv.
    """

    def __init__(self, vulnerability_files: Union[List[str], str], openscv_csv_path: str):
        """
        Initialize the mapper with the paths to the vulnerability files and the OpenSCV file.

        Args:
            vulnerability_files: Path(s) to the vulnerability CSV files. Can be:
                                - A string with a single file path
                                - A list of file paths
                                - A string with a glob pattern (e.g., 'output_*.csv')
            openscv_csv_path: Path to the openscvfull.csv file
        """
        if isinstance(vulnerability_files, str):
            if '*' in vulnerability_files:
                self.vulnerability_files = glob.glob(vulnerability_files)
            else:
                self.vulnerability_files = [vulnerability_files]
        else:
            self.vulnerability_files = vulnerability_files

        self._validate_input_files()

        self.vulnerability_df = self._read_vulnerability_files()

        self.openscv_df = pd.read_csv(openscv_csv_path)

        self.openscv_df['clean_swc'] = self.openscv_df['SWC'].apply(
            lambda x: str(x) if pd.notna(x) and str(x) != '-' and str(x) != 'nan' else None
        )

        self.mapping_rules = self._create_mapping_rules()

        self.openscv_entries_cache = {}

        self.stats = {
            'total_vulnerabilities': len(self.vulnerability_df),
            'mapped_by_swc': 0,
            'mapped_by_keyword': 0,
            'unmapped': 0,
            'mapped_swc_ids': set(),
            'unmapped_vulnerabilities': [],
            'by_source_file': {}
        }

    def _validate_input_files(self) -> None:
        """
        Validate that all specified input files exist and are accessible.
        Raises an exception if any file is missing.
        """
        missing_files = [f for f in self.vulnerability_files if not os.path.exists(f)]
        if missing_files:
            raise FileNotFoundError(f"The following input files were not found: {', '.join(missing_files)}")

    def _read_vulnerability_files(self) -> pd.DataFrame:
        """
        Read and merge all vulnerability files into a single DataFrame.

        Returns:
            A DataFrame containing data from all input vulnerability files
        """
        dfs = []

        for file_path in self.vulnerability_files:
            file_name = os.path.basename(file_path)
            category = file_name.replace('output_', '').replace('.csv', '')

            df = pd.read_csv(file_path)

            df['source_file'] = file_name
            df['vulnerability_category'] = category
            dfs.append(df)

            # Update statistics
            # self.stats['by_source_file'][file_name] = len(df)

        if dfs:
            vuln_df = pd.concat(dfs, ignore_index=True)
            return vuln_df.drop_duplicates(subset=['Tool', 'File', 'Vulnerability'], keep=False)
        else:
            return pd.DataFrame(columns=[
                'Tool', 'File', 'Contract', 'Vulnerability', 'Severity',
                'SWC-ID', 'Remediation', 'Description/More Info',
                'Execution time', 'Total Time', 'source_file', 'vulnerability_category'
            ])

    def _create_mapping_rules(self) -> Dict[str, Dict[str, Any]]:
        """
        Create mapping rules based on SWC-IDs and keywords.
        Also extracts keywords from the openscv-full.csv descriptions.

        Returns:
            Dictionary of mapping rules
        """
        base_rules = {
            "SWC-101": {
                "categories": ["Integer Arithmetic Bugs", "arithmetic"],
                "keywords": ["integer overflow", "overflow", "underflow", "arithmetic",
                             "addition overflow", "subtraction overflow", "multiply overflow"]
            },

            "SWC-106": {
                "categories": ["Access Control", "access control"],
                "keywords": ["unprotected selfdestruct instruction"]
            },
            "SWC-117": {
                "categories": ["Access Control", "access control"],
                "keywords": ["signature malleability"]
            },
            "SWC-118": {
                "categories": ["Access Control", "access control"],
                "keywords": ["incorrect constructor name"]
            },
            "SWC-121": {
                "categories": ["Access Control", "access control"],
                "keywords": ["missing protection against signature replay attacks"]
            },
            "SWC-122": {
                "categories": ["Access Control", "access control"],
                "keywords": ["lack of proper signature verification"]
            },
            "SWC-124": {
                "categories": ["Access Control", "access control"],
                "keywords": ["write to arbitrary storage location"]
            },
            "SWC-128": {
                "categories": ["Denial of Service", "denial of service"],
                "keywords": ["DoS with block gas limit"]
            },
            "SWC-132": {
                "categories": ["Denial of Service", "denial of service"],
                "keywords": ["unexpected ether balance"]
            },
            "SWC-134": {
                "categories": ["Denial of Service", "denial of service"],
                "keywords": ["message call with hardcoded gas amount"]
            },
            "SWC-102": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["outdated compiler version"]
            },
            "SWC-109": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["uninitialized storage pointer"]
            },
            "SWC-111": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["use of deprecated solidity functions"]
            },
            "SWC-119": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["shadowing state variables"]
            },
            "SWC-123": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["requirement violation"]
            },
            "SWC-125": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["incorrect inheritance order"]
            },
            "SWC-126": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["insufficient gas griefing"]
            },
            "SWC-127": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["arbitrary jump with function type variable"]
            },
            "SWC-129": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["typographical error"]
            },
            "SWC-130": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["right to left override control character", "right-to-left override control character"]
            },
            "SWC-131": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["presence of unused variables", "unused variables"]
            },
            "SWC-133": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["hash collisions with multiple variable length arguments", "unused variables"]
            },
            "SWC-135": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["code with no effects", "no effects"]
            },
            "SWC-136": {
                "categories": ["Unknown Unknowns", "unknown unknowns"],
                "keywords": ["unencrypted private data on-chain", "unencrypted private data"]
            },
            "SWC-116": {
                "categories": ["Dependence on predictable environment variable", "time_manipulation"],
                "keywords": ["timestamp", "block.timestamp", "now", "block.number", "time manipulation"]
            },
            "SWC-114": {
                "categories": ["Transaction Order Dependence", "front_running"],
                "keywords": ["transaction order", "race condition", "front running"]
            },
            "SWC-110": {
                "categories": ["Exception State"],
                "keywords": ["exception", "assert", "require", "revert"]
            },
            "SWC-105": {
                "categories": ["Unprotected Ether Withdrawal"],
                "keywords": ["ether withdrawal", "unauthorized", "unprotected"]
            },
            "SWC-107": {
                "categories": ["reentrancy"],
                "keywords": ["reentrancy", "reentrant", "re-entrancy", "recursive call"]
            },
            "SWC-108": {
                "categories": [],
                "keywords": ["naming convention", "mixedcase", "camelcase", "style"]
            },
            "SWC-103": {
                "categories": [],
                "keywords": ["floating pragma", "compiler version", "solidity version"]
            },
            "SWC-120": {
                "categories": ["bad_randomness"],
                "keywords": ["weak random", "bad randomness", "predictable random", "entropy", "weak sources of randomness from chain attributes"]
            },
            "SWC-113": {
                "categories": ["denial_of_service"],
                "keywords": ["denial of service", "dos", "gas limit", "block gas limit"]
            },
            "SWC-112": {
                "categories": ["access_control"],
                "keywords": ["access control", "authorization", "permission", "ownership"]
            },
            "SWC-104": {
                "categories": ["unchecked_low_level_calls"],
                "keywords": ["unchecked call", "low level call", "external call", "call.value"]
            },
            "SWC-115": {
                "categories": ["tx.origin"],
                "keywords": ["tx.origin", "authentication", "transaction origin"]
            }
        }

        category_to_swc = {
            "arithmetic": "SWC-101",
            "access_control": "SWC-112",
            "time_manipulation": "SWC-116",
            "reentrancy": "SWC-107",
            "front_running": "SWC-114",
            "denial_of_service": "SWC-113",
            "bad_randomness": "SWC-120",
            "unchecked_low_level_calls": "SWC-104"
        }

        for _, row in self.openscv_df.iterrows():
            swc_id = row['clean_swc']
            if not swc_id:
                continue

            if swc_id not in base_rules:
                base_rules[swc_id] = {
                    "categories": [],
                    "keywords": []
                }

            if pd.notna(row['Synonyms']):
                synonyms = str(row['Synonyms']).lower().split(',')
                for synonym in synonyms:
                    synonym = synonym.strip()
                    if synonym and synonym not in base_rules[swc_id]["keywords"]:
                        base_rules[swc_id]["keywords"].append(synonym)

        return base_rules

    def extract_swc_id(self, swc_id_field: str) -> Optional[str]:
        """
        Extract the SWC-ID from the field in output CSV files.

        Args:
            swc_id_field: The SWC-ID field from the CSV

        Returns:
            Cleaned SWC-ID or None if not found
        """
        if not isinstance(swc_id_field, str):
            return None

        match = re.search(r'SWC-(\d+)', swc_id_field)
        return f"SWC-{match.group(1)}" if match else None

    def map_vulnerability_by_swc(self, vulnerability_row: pd.Series) -> Optional[str]:
        """
        Map a vulnerability to an SWC-ID based on its SWC field.

        Args:
            vulnerability_row: A row from a vulnerability CSV file

        Returns:
            SWC-ID or None if not found
        """
        swc_id = self.extract_swc_id(vulnerability_row['SWC-ID'])
        if swc_id:
            self.stats['mapped_by_swc'] += 1
            self.stats['mapped_swc_ids'].add(swc_id)
            return swc_id
        return None

    def map_vulnerability_by_keyword(self, vulnerability_row: pd.Series) -> Optional[str]:
        """
        Map a vulnerability to an SWC-ID based on keywords in its description.
        Uses a scoring system to find the best match.

        Args:
            vulnerability_row: A row from a vulnerability CSV file

        Returns:
            SWC-ID or None if no good match found
        """
        vuln_desc: str = str(vulnerability_row['Vulnerability']).lower()
        tool: str = str(vulnerability_row['Tool']).lower()
        if tool == "slither":
            slither_mapping = {
                'arbitrary_send': 'Access Control',
                'arbitrary-send': 'Access Control',
                'arbitrary_send_eth': 'Access Control',
                'arbitrary-send-eth': 'Access Control',
                'controlled-delegatecall': 'Access Control',
                'controlled_delegatecall': 'Access Control',
                'incorrect_modifier': 'Access Control',
                'suicidal': 'Access Control',
                'tx-origin': 'Access Control',
                'tx_origin': 'Access Control',
                'missing_zero_check': 'Arithmetic Issues',
                'incorrect_equality': 'Arithmetic Issues',
                'boolean_equal': 'Arithmetic Issues',
                'divide_before_multiply': 'Arithmetic Issues',
                'weak_prng': 'Bad Randomness',
                'calls_loop': 'Denial of Service',
                'calls-loop': 'Denial of Service',
                'controlled_array_length': 'Denial of Service',
                'controlled-array-length': 'Denial of Service',
                'locked_ether': 'Denial of Service',
                'return_bomb': 'Denial of Service',
                'reentrancy-benign': 'REENTRANCY',
                'reentrancy_benign': 'REENTRANCY',
                'reentrancy-eth': 'REENTRANCY',
                'reentrancy_eth': 'REENTRANCY',
                'reentrancy-no-eth': 'REENTRANCY',
                'reentrancy_no_eth': 'REENTRANCY',
                'reentrancy_events': 'REENTRANCY',
                'reentrancy_unlimited_gas': 'REENTRANCY',
                'timestamp': 'Time Manipulation',
                'unused-return': 'Unchecked Return Values',
                'unused_return': 'Unchecked Return Values',
                'low-level-calls': 'Unchecked Return Values',
                'low_level-calls': 'Unchecked Return Values',
                'low_level_calls': 'Unchecked Return Values',
                'unchecked_lowlevel': 'Unchecked Return Values',
                'unchecked_send': 'Unchecked Return Values',
                'unchecked_transfer': 'Unchecked Return Values',
                'incorrect-equality': 'Unknown Unknowns',
                'locked-ether': 'Unknown Unknowns',
                'uninitialized-local': 'Unknown Unknowns',
                'uninitialized_local': 'Unknown Unknowns',
                'uninitialized-state': 'Unknown Unknowns',
                'uninitialized-storage': 'Unknown Unknowns',
                'uninitialized_state': 'Unknown Unknowns',
                'uninitialized_storage': 'Unknown Unknowns',
                'shadowing_state': 'Unknown Unknowns',
                'encode_packed_collision': 'Unknown Unknowns',
                'tautology': 'Unknown Unknowns',
                "reentrancy": "Reentrancy",
                "reentrant": "Reentrancy",
                "external call": "Reentrancy",
                "overflow": "Arithmetic Issues",
                "underflow": "Arithmetic Issues",
                "integer arithmetic": "Arithmetic Issues",
                "arithmetic": "Arithmetic Issues",
                "access control": "Access Control",
                "authorization": "Access Control",
                "permissions": "Access Control",
                "tx.origin": "Access Control",
                "constructor name": "Access Control",
                "arbitrary write": "Access Control",
                "random": "Bad Randomness",
                "randomness": "Bad Randomness",
                "dos": "Denial of Service",
                "denial of service": "Denial of Service",
                "gas limit": "Denial of Service",
                "front run": "Front-Running",
                "transaction order": "Front-Running",
                "race condition": "Front-Running",
                "block value": "Time Manipulation",
                "time": "Time Manipulation",
                "unchecked return value from external call.": "Unchecked Return Values",
                "unchecked": "Unchecked Return Values",
                "return value": "Unchecked Return Values",
                "low level call": "Unchecked Return Values",
                "send": "Unchecked Return Values",
                "call": "Unchecked Return Values",
                "short address": "Short Address/Parameter Attack",
                "parameter": "Short Address/Parameter Attack",
                "unchecked-lowlevel": "Unchecked Return Values",
                "unchecked-send": "Unchecked Return Values",
                "unchecked-transfer": "Unchecked Return Values",
                "divide-before-multiply": "Arithmetic Issues",
                "weak-prng": "Bad Randomness",
            }

            slither_to_swc = {
                # Access Control
                'arbitrary_send': 'SWC-105',
                'arbitrary-send': 'SWC-105',
                'arbitrary_send_eth': 'SWC-105',
                'arbitrary-send-eth': 'SWC-105',
                'controlled-delegatecall': 'SWC-112',
                'controlled_delegatecall': 'SWC-112',
                'incorrect_modifier': 'SWC-123',
                'suicidal': 'SWC-106',
                'tx-origin': 'SWC-115',
                'tx_origin': 'SWC-115',
                'arbitrary write': 'SWC-124',
                'authorization': 'SWC-105',
                'permissions': 'SWC-105',
                'tx.origin': 'SWC-115',
                'constructor name': 'SWC-118',
                'access control': 'SWC-105',

                # Arithmetic Issues
                'missing_zero_check': 'SWC-101',
                'incorrect_equality': 'SWC-101',
                'boolean_equal': 'SWC-101',
                'divide_before_multiply': 'SWC-101',
                'divide-before-multiply': 'SWC-101',
                'overflow': 'SWC-101',
                'underflow': 'SWC-101',
                'integer arithmetic': 'SWC-101',
                'arithmetic': 'SWC-101',

                # Bad Randomness
                'weak_prng': 'SWC-120',
                'weak-prng': 'SWC-120',
                'random': 'SWC-120',
                'randomness': 'SWC-120',

                # Denial of Service
                'calls_loop': 'SWC-128',
                'calls-loop': 'SWC-128',
                'controlled_array_length': 'SWC-128',
                'controlled-array-length': 'SWC-128',
                'locked_ether': 'SWC-132',
                'locked-ether': 'SWC-132',
                'return_bomb': 'SWC-113',
                'dos': 'SWC-113',
                'denial of service': 'SWC-113',
                'gas limit': 'SWC-128',

                # Reentrancy
                'reentrancy-benign': 'SWC-107',
                'reentrancy_benign': 'SWC-107',
                'reentrancy-eth': 'SWC-107',
                'reentrancy_eth': 'SWC-107',
                'reentrancy-no-eth': 'SWC-107',
                'reentrancy_no_eth': 'SWC-107',
                'reentrancy_events': 'SWC-107',
                'reentrancy_unlimited_gas': 'SWC-107',
                'reentrancy': 'SWC-107',
                'reentrant': 'SWC-107',
                'external call': 'SWC-107',

                # Time Manipulation
                'timestamp': 'SWC-116',
                'block value': 'SWC-116',
                'time': 'SWC-116',

                # Unchecked Return Values
                'unused-return': 'SWC-104',
                'unused_return': 'SWC-104',
                'low-level-calls': 'SWC-104',
                'low_level-calls': 'SWC-104',
                'low_level_calls': 'SWC-104',
                'unchecked_lowlevel': 'SWC-104',
                'unchecked-lowlevel': 'SWC-104',
                'unchecked_send': 'SWC-104',
                'unchecked-send': 'SWC-104',
                'unchecked_transfer': 'SWC-104',
                'unchecked-transfer': 'SWC-104',
                'unchecked return value from external call.': 'SWC-104',
                'unchecked': 'SWC-104',
                'return value': 'SWC-104',
                'low level call': 'SWC-104',
                'send': 'SWC-104',
                'call': 'SWC-104',

                # Front-Running
                'front run': 'SWC-114',
                'transaction order': 'SWC-114',
                'race condition': 'SWC-114',

                # Short Address/Parameter Attack
                'short address': 'SWC-121',
                'parameter': 'SWC-121',

                # Unknown Unknowns: we map it to closest SWC
                'incorrect-equality': 'SWC-123',
                'uninitialized-local': 'SWC-109',
                'uninitialized_local': 'SWC-109',
                'uninitialized-state': 'SWC-109',
                'uninitialized-storage': 'SWC-109',
                'uninitialized_state': 'SWC-109',
                'uninitialized_storage': 'SWC-109',
                'shadowing-state': 'SWC-119',
                'encode_packed_collision': 'SWC-133',
                'tautology': 'SWC-123',
                'erc20-interface': 'SWC-123',
                'encode-packed-collision': 'SWC-133',
                'constant-function-asm': 'SWC-123',
            }
            # if vuln_desc in slither_mapping:
            if vuln_desc in slither_to_swc.keys():
                self.stats['mapped_by_swc'] += 1
                print('Mapped SWC {}: {}'.format(vuln_desc, slither_to_swc[vuln_desc]))
                return slither_to_swc[vuln_desc]

        if 'vulnerability_category' in vulnerability_row:
            category = vulnerability_row['vulnerability_category']
            category_mapping = {
                "arithmetic": "SWC-101",
                "access_control": "SWC-112",
                "time_manipulation": "SWC-116",
                "short_addresses": "SWC-121",
                "reentrancy": "SWC-107",
                "front_running": "SWC-114",
                "denial_of_service": "SWC-113",
                "bad_randomness": "SWC-120",
                "unchecked_low_level_calls": "SWC-104"
            }

            if category in category_mapping:
                self.stats['mapped_by_keyword'] += 1
                self.stats['mapped_swc_ids'].add(category_mapping[category])
                return category_mapping[category]

        if vuln_desc.startswith("===="):
            category = vuln_desc.replace("=", "").strip().lower()
            for swc_id, rules in self.mapping_rules.items():
                if any(cat.lower() == category for cat in rules["categories"]):
                    self.stats['mapped_by_keyword'] += 1
                    self.stats['mapped_swc_ids'].add(swc_id)
                    return swc_id

        if "version constraint" in vuln_desc and "contains known severe issues" in vuln_desc:
            self.stats['mapped_by_keyword'] += 1
            self.stats['mapped_swc_ids'].add("SWC-103")
            return "SWC-103"

        scores = defaultdict(int)
        for swc_id, rules in self.mapping_rules.items():
            for keyword in rules["keywords"]:
                if keyword in vuln_desc:
                    scores[swc_id] += len(keyword)

        if scores:
            best_swc_id = max(scores.items(), key=lambda x: x[1])
            if best_swc_id[1] > 5:
                self.stats['mapped_by_keyword'] += 1
                self.stats['mapped_swc_ids'].add(best_swc_id[0])
                return best_swc_id[0]


        self.stats['unmapped'] += 1
        self.stats['unmapped_vulnerabilities'].append(vuln_desc)
        print("unmapped vulnerabilities:", vuln_desc)

        return None

    def get_openscv_entries(self, swc_id: str) -> List[Dict[str, Any]]:
        """
        Get all entries from openscvfull.csv that match a given SWC-ID.
        Uses caching for performance.

        Args:
            swc_id: The SWC-ID to match

        Returns:
            List of matching entries with relevant fields
        """
        if not swc_id:
            return []

        if swc_id in self.openscv_entries_cache:
            return self.openscv_entries_cache[swc_id]

        matching_entries = self.openscv_df[self.openscv_df['clean_swc'] == swc_id]

        result = []
        for _, row in matching_entries.iterrows():
            result.append({
                "index": row['Index '] if 'Index ' in row else None,
                "defect_type": row['DefectType'] if 'DefectType' in row else None,
                "description": row['Desc'] if 'Desc' in row else None,
                "synonyms": row['Synonyms'] if 'Synonyms' in row else None
            })

        self.openscv_entries_cache[swc_id] = result

        return result

    def map_vulnerabilities(self) -> pd.DataFrame:
        """
        Map all vulnerabilities from the input CSV files to their corresponding
        entries in openscvfull.csv.

        Returns:
            DataFrame with mapping results
        """
        results = []

        self.stats = {
            'total_vulnerabilities': len(self.vulnerability_df),
            'mapped_by_swc': 0,
            'mapped_by_keyword': 0,
            'unmapped': 0,
            'mapped_swc_ids': set(),
            'unmapped_vulnerabilities': [],
            'by_source_file': {f: 0 for f in self.stats['by_source_file'].keys()}
        }

        for _, vuln_row in self.vulnerability_df.iterrows():
            swc_id = self.map_vulnerability_by_swc(vuln_row)
            mapping_method = "SWC-ID" if swc_id else None

            if not swc_id:
                swc_id = self.map_vulnerability_by_keyword(vuln_row)
                mapping_method = "Keyword" if swc_id else None

            openscv_entries = self.get_openscv_entries(swc_id)

            result = {
                "tool": vuln_row['Tool'] if 'Tool' in vuln_row else None,
                "file": vuln_row['File'] if 'File' in vuln_row else None,
                "contract": vuln_row['Contract'] if 'Contract' in vuln_row else None,
                "vulnerability": vuln_row['Vulnerability'] if 'Vulnerability' in vuln_row else None,
                "severity": vuln_row['Severity'] if 'Severity' in vuln_row else None,
                "original_swc_id": vuln_row['SWC-ID'] if 'SWC-ID' in vuln_row else None,
                "mapped_swc_id": swc_id,
                "mapping_method": mapping_method,
                "openscv_entries": openscv_entries,
                "has_match": len(openscv_entries) > 0,
                "source_file": vuln_row['source_file'] if 'source_file' in vuln_row else None,
                "vulnerability_category": vuln_row[
                    'vulnerability_category'] if 'vulnerability_category' in vuln_row else None
            }

            results.append(result)

        result_df = pd.DataFrame(results)

        return result_df

    def map_vulnerability_to_openscv(self, openscv_entries, vulnerability_row, openscv_swc_mapping=None):
        """
        Maps a vulnerability detection entry to the most appropriate OpenSCV entry using
        both vulnerability information and remediation guidance.

        Args:
            openscv_entries (list): List of OpenSCV entry dictionaries
            vulnerability_row (dict): A row from the lightcross dataset
            openscv_swc_mapping (DataFrame, optional): DataFrame containing the OpenSCV to SWC mappings

        Returns:
            dict: The matching OpenSCV entry, or None if no match found
        """

        vulnerability_name = vulnerability_row.get('Vulnerability', '').lower()
        remediation_text = vulnerability_row.get('Remediation', '').lower()
        swc_id = vulnerability_row.get('SWC.ID', '')
        description_info = vulnerability_row.get('Description.More.Info', '').lower()

        if swc_id and not swc_id.startswith('SWC-'):
            if re.match(r'^\d+$', swc_id):  # If it's just a number
                swc_id = f'SWC-{swc_id}'

        # 1) Try to match using SWC ID if we have the mapping data
        if openscv_swc_mapping is not None and swc_id:
            matching_indexes = openscv_swc_mapping[openscv_swc_mapping['SWC ID'] == swc_id]['OpenSCV Index'].tolist()

            if matching_indexes:
                # Find the OpenSCV entries with these indexes
                matches = [entry for entry in openscv_entries if
                           any(idx in entry.get('index', '') for idx in matching_indexes)]
                if matches:
                    # If we have multiple matches, narrow down by vulnerability name and remediation
                    if len(matches) > 1:
                        best_match = None
                        highest_score = 0

                        for entry in matches:
                            score = 0
                            synonyms = entry.get('synonyms', '').lower()
                            description = entry.get('description', '').lower()

                            # Check vulnerability name against synonyms
                            if vulnerability_name in synonyms:
                                score += 3
                            elif any(token in vulnerability_name for token in synonyms.split(', ')):
                                score += 2

                            # Check remediation text against OpenSCV description
                            if remediation_text:
                                remediation_words = set(re.findall(r'\b\w+\b', remediation_text))
                                description_words = set(re.findall(r'\b\w+\b', description))

                                # Count matching words
                                common_words = remediation_words.intersection(description_words)
                                score += len(common_words)

                            if score > highest_score:
                                highest_score = score
                                best_match = entry

                        return best_match if highest_score > 0 else matches[0]
                    else:
                        return matches[0]

        #  2) Scoring-based matching using all available fields
        best_match = None
        highest_score = 0

        # Extract key terms from vulnerability text fields
        vuln_terms = set(re.findall(r'\b\w+\b', vulnerability_name))
        if remediation_text:
            vuln_terms.update(set(re.findall(r'\b\w+\b', remediation_text)))
        if description_info:
            vuln_terms.update(set(re.findall(r'\b\w+\b', description_info)))

        vulnerability_keywords = {
            'overflow': ['7.1.2'],
            'underflow': ['7.1.1'],
            'divide': ['7.2.1', '7.2.2'],
            'division': ['7.2.1', '7.2.2'],
            'zero': ['7.2.1'],
            'precision': ['7.2.2', '7.3.1'],
            'truncat': ['7.3.1'],
            'sign': ['7.3.2'],
            'integer': ['7.1.1', '7.1.2', '7.2.2', '7.3.1']
        }

        # Check for keyword matches
        matching_indexes = []
        for term in vuln_terms:
            for keyword, indexes in vulnerability_keywords.items():
                if keyword in term:
                    matching_indexes.extend(indexes)

        # Count frequency of matching indexes to identify most likely category
        index_counter = Counter(matching_indexes)

        for entry in openscv_entries:
            score = 0
            entry_index = entry.get('index', '').split()[0]  # Get just the number part
            synonyms = entry.get('synonyms', '').lower()
            description = entry.get('description', '').lower()

            # Add score based on keyword matching
            score += index_counter[entry_index] * 2

            if vulnerability_name in synonyms:
                score += 4

            for synonym in synonyms.split(', '):
                if synonym in vulnerability_name:
                    score += 2
                elif any(term in synonym for term in vuln_terms):
                    score += 1

            # Check remediation text against OpenSCV description
            if remediation_text:
                remediation_words = set(re.findall(r'\b\w+\b', remediation_text))
                description_words = set(re.findall(r'\b\w+\b', description))

                common_words = remediation_words.intersection(description_words)
                score += len(common_words)

            if vulnerability_name == 'divide-before-multiply' and entry_index == '7.2.2':
                score += 5

            if score > highest_score:
                highest_score = score
                best_match = entry

        if highest_score >= 2:
            return best_match

        return None

    def export_mapping(self, output_path: str) -> None:
        """
        Export the mapping results to a CSV file.

        Args:
            output_path: Path to save the output CSV
        """
        result_df = self.map_vulnerabilities()

        flattened_results = []
        for _, row in result_df.iterrows():
            openscv_entries = row['openscv_entries']

            if not openscv_entries:
                # No matching entries found, still include the vulnerability
                flattened_results.append({
                    "tool": row['tool'],
                    "file": row['file'],
                    "contract": row['contract'],
                    "vulnerability": row['vulnerability'],
                    "severity": row['severity'],
                    "original_swc_id": row['original_swc_id'],
                    "mapped_swc_id": row['mapped_swc_id'],
                    "mapping_method": row['mapping_method'],
                    "openscv_index": None,
                    "openscv_defect_type": None,
                    "openscv_description": None,
                    "source_file": row['source_file'],
                    "vulnerability_category": row['vulnerability_category']
                })
            elif len(openscv_entries) == 1:
                for entry in openscv_entries:
                    flattened_results.append({
                        "tool": row['tool'],
                        "file": row['file'],
                        "contract": row['contract'],
                        "vulnerability": row['vulnerability'],
                        "severity": row['severity'],
                        "original_swc_id": row['original_swc_id'],
                        "mapped_swc_id": row['mapped_swc_id'],
                        "mapping_method": row['mapping_method'],
                        "openscv_index": entry['index'],
                        "openscv_defect_type": entry['defect_type'],
                        "openscv_description": entry['description'],
                        "source_file": row['source_file'],
                        "vulnerability_category": row['vulnerability_category']
                    })
            elif len(openscv_entries) > 1:
                entry = self.map_vulnerability_to_openscv(openscv_entries, row)
                flattened_results.append({
                    "tool": row['tool'],
                    "file": row['file'],
                    "contract": row['contract'],
                    "vulnerability": row['vulnerability'],
                    "severity": row['severity'],
                    "original_swc_id": row['original_swc_id'],
                    "mapped_swc_id": row['mapped_swc_id'],
                    "mapping_method": row['mapping_method'],
                    "openscv_index": entry['index'],
                    "openscv_defect_type": entry['defect_type'],
                    "openscv_description": entry['description'],
                    "source_file": row['source_file'],
                    "vulnerability_category": row['vulnerability_category']
                })

        pd.DataFrame(flattened_results).to_csv(output_path, index=False)

    def export_json_mapping(self, output_path: str) -> None:
        """
        Export the mapping results to a JSON file with more detailed structure.

        Args:
            output_path: Path to save the output JSON
        """
        result_df = self.map_vulnerabilities()

        results_list = result_df.to_dict(orient='records')

        with open(output_path, 'w') as f:
            json.dump(results_list, f, indent=2)

    def generate_statistics(self, output_dir: str = None) -> Dict[str, Any]:
        """
        Generate statistics about the mapping process and optionally
        create visualizations.

        Args:
            output_dir: Directory to save the visualizations (optional)

        Returns:
            Dictionary of statistics
        """
        result_df = self.map_vulnerabilities()

        match_stats = {
            'total': len(result_df),
            'matched': result_df['has_match'].sum(),
            'unmatched': len(result_df) - result_df['has_match'].sum(),
            'match_rate': round(result_df['has_match'].mean() * 100, 2)
        }

        swc_counts = Counter(
            result_df[result_df['mapped_swc_id'].notna()]['mapped_swc_id']
        )

        defect_types = []
        for entries in result_df['openscv_entries']:
            for entry in entries:
                if entry['defect_type']:
                    defect_types.append(entry['defect_type'])
        defect_type_counts = Counter(defect_types)

        file_counts = Counter(result_df['source_file'])
        category_counts = Counter(result_df['vulnerability_category'])

        mapping_by_category = {}
        for category in category_counts.keys():
            category_df = result_df[result_df['vulnerability_category'] == category]
            mapping_by_category[category] = {
                'swc_id': (category_df['mapping_method'] == 'SWC-ID').sum(),
                'keyword': (category_df['mapping_method'] == 'Keyword').sum(),
                'unmapped': category_df['mapping_method'].isna().sum(),
                'total': len(category_df),
                'match_rate': round(category_df['has_match'].mean() * 100, 2)
            }

        statistics = {
            'mapping_method': {
                'swc_id': self.stats['mapped_by_swc'],
                'keyword': self.stats['mapped_by_keyword'],
                'unmapped': self.stats['unmapped']
            },
            'match_stats': match_stats,
            'swc_counts': dict(swc_counts),
            'defect_type_counts': dict(defect_type_counts),
            'mapped_swc_ids': list(self.stats['mapped_swc_ids']),
            'file_counts': dict(file_counts),
            'category_counts': dict(category_counts),
            'mapping_by_category': mapping_by_category,
            'unmapped_sample': self.stats['unmapped_vulnerabilities'][:10] if self.stats[
                'unmapped_vulnerabilities'] else []
        }

        if output_dir:
            self._generate_visualizations(statistics, output_dir)

        return statistics

    def _generate_visualizations(self, statistics: Dict[str, Any], output_dir: str) -> None:
        """
        Generate visualizations of the mapping statistics.

        Args:
            statistics: Dictionary of statistics
            output_dir: Directory to save the visualizations
        """
        os.makedirs(output_dir, exist_ok=True)

        plt.figure(figsize=(10, 6))
        labels = ['Mapped by SWC-ID', 'Mapped by Keyword', 'Unmapped']
        sizes = [
            statistics['mapping_method']['swc_id'],
            statistics['mapping_method']['keyword'],
            statistics['mapping_method']['unmapped']
        ]
        plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
        plt.axis('equal')
        plt.title('Vulnerability Mapping Methods')
        plt.savefig(os.path.join(output_dir, 'mapping_methods_pie.pdf'))
        plt.close()

        plt.figure(figsize=(12, 8))
        swc_ids = list(statistics['swc_counts'].keys())
        counts = list(statistics['swc_counts'].values())

        swc_counts_sorted = sorted(zip(swc_ids, counts), key=lambda x: x[1], reverse=True)
        swc_ids = [x[0] for x in swc_counts_sorted]
        counts = [x[1] for x in swc_counts_sorted]

        plt.bar(swc_ids, counts)
        plt.xlabel('SWC-ID')
        plt.ylabel('Count')
        plt.title('Vulnerability Distribution by SWC-ID')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'swc_id_distribution.pdf'))
        plt.close()

        plt.figure(figsize=(12, 8))
        defect_types = list(statistics['defect_type_counts'].keys())
        defect_counts = list(statistics['defect_type_counts'].values())

        defect_counts_sorted = sorted(zip(defect_types, defect_counts), key=lambda x: x[1], reverse=True)
        defect_types = [x[0] for x in defect_counts_sorted]
        defect_counts = [x[1] for x in defect_counts_sorted]

        plt.bar(defect_types, defect_counts)
        plt.xlabel('Defect Type')
        plt.ylabel('Count')
        plt.title('Defect Type Distribution')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'defect_type_distribution.pdf'))
        plt.close()

        plt.figure(figsize=(12, 8))
        categories = list(statistics['category_counts'].keys())
        category_counts = list(statistics['category_counts'].values())

        category_counts_sorted = sorted(zip(categories, category_counts), key=lambda x: x[1], reverse=True)
        categories = [x[0] for x in category_counts_sorted]
        category_counts = [x[1] for x in category_counts_sorted]

        plt.bar(categories, category_counts)
        plt.xlabel('Vulnerability Category')
        plt.ylabel('Count')
        plt.title('Vulnerability Distribution by Category')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'category_distribution.pdf'))
        plt.close()

        plt.figure(figsize=(14, 8))
        categories = list(statistics['mapping_by_category'].keys())

        categories_sorted = sorted(
            categories,
            key=lambda x: statistics['mapping_by_category'][x]['total'],
            reverse=True
        )

        swc_id_counts = [statistics['mapping_by_category'][cat]['swc_id'] for cat in categories_sorted]
        keyword_counts = [statistics['mapping_by_category'][cat]['keyword'] for cat in categories_sorted]
        unmapped_counts = [statistics['mapping_by_category'][cat]['unmapped'] for cat in categories_sorted]

        bar_width = 0.8
        indices = np.arange(len(categories_sorted))

        plt.bar(indices, swc_id_counts, bar_width, label='SWC-ID')
        plt.bar(indices, keyword_counts, bar_width, bottom=swc_id_counts, label='Keyword')
        plt.bar(indices, unmapped_counts, bar_width, bottom=[i + j for i, j in zip(swc_id_counts, keyword_counts)],
                label='Unmapped')

        plt.xlabel('Vulnerability Category')
        plt.ylabel('Count')
        plt.title('Mapping Methods by Vulnerability Category')
        plt.xticks(indices, categories_sorted, rotation=45, ha='right')
        plt.legend()
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'mapping_by_category.pdf'))
        plt.close()